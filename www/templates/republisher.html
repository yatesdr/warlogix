{{template "header" .}}

<div class="page-header">
    <h1>Republisher</h1>
</div>

<div class="republisher-layout">
    <div class="republisher-tree-wrapper">
        <div class="plc-picker-wrapper" id="plc-selector"></div>
        <div class="republisher-tree" id="republisher-tree">
            {{template "republisher_tree.html" .}}
        </div>
    </div>
    <div class="republisher-details" id="republisher-details">
        <div class="details-placeholder">
            Select a tag to view details
        </div>
    </div>
</div>

<!-- Tag Add/Edit Modal -->
<div id="tag-modal" class="modal" style="display:none">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="tag-modal-title">Add Tag</h3>
            <button class="modal-close" onclick="WarLink.hideModal('tag-modal')">&times;</button>
        </div>
        <form onsubmit="submitTagModal(event)">
            <div class="modal-body">
                <input type="hidden" id="tag-modal-plc" />
                <input type="hidden" id="tag-modal-mode" value="add" />
                <input type="hidden" id="tag-modal-original-name" />
                <div id="tag-modal-fields"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn" onclick="WarLink.hideModal('tag-modal')">Cancel</button>
                <button type="submit" class="btn btn-primary" id="tag-modal-submit">Add Tag</button>
            </div>
        </form>
    </div>
</div>

<script>
// Store state in localStorage
var selectedPLC = localStorage.getItem('republisher-selected-plc') || '';
var collapsedSections = JSON.parse(localStorage.getItem('republisher-sections-collapsed') || '{}');
var expandedTags = JSON.parse(localStorage.getItem('republisher-expanded') || '{}');
var expandedChildren = JSON.parse(localStorage.getItem('republisher-children-expanded') || '{}');
var selectedInfo = JSON.parse(localStorage.getItem('republisher-selected-info') || 'null');
var expandedValueNodes = JSON.parse(localStorage.getItem('republisher-value-expanded') || '{}');

// Fetch a tag's value on demand if not already cached in the DOM.
// Calls callback(tagItem) after the value is available.
function ensureTagValue(plc, tagName, tagItem, callback) {
    var hasValue = !!tagItem.dataset.json;
    var needsMemberTypes = tagItem.dataset.isStruct === 'true' && !tagItem.dataset.memberTypes;

    if (hasValue && !needsMemberTypes) {
        callback(tagItem);
        return;
    }
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName))
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            return resp.json();
        })
        .then(function(data) {
            var jsonValue = JSON.stringify(data.value);
            tagItem.dataset.json = jsonValue;
            if (data.type) tagItem.dataset.type = data.type;
            if (data.member_types) {
                tagItem.dataset.memberTypes = JSON.stringify(data.member_types);
            } else if (needsMemberTypes) {
                // Mark that we tried â€” no member types for this PLC type
                tagItem.dataset.memberTypes = 'null';
            }

            // Upgrade to struct if value is an object (only on first fetch)
            if (!hasValue) {
                var isStruct = data.value !== null && typeof data.value === 'object' && !Array.isArray(data.value);
                if (isStruct && !tagItem.classList.contains('has-children')) {
                    tagItem.classList.add('has-children', 'collapsed');
                    tagItem.dataset.isStruct = 'true';
                    tagItem.dataset.fieldCount = String(Object.keys(data.value).length);
                    var tagRow = tagItem.querySelector('.tag-row');
                    if (tagRow && !tagRow.querySelector('.tag-expand')) {
                        var expandSpan = document.createElement('span');
                        expandSpan.className = 'tag-expand';
                        expandSpan.innerHTML = '&#9660;';
                        expandSpan.setAttribute('onclick', 'toggleTagExpand(event, this)');
                        tagRow.insertBefore(expandSpan, tagRow.firstChild);
                    }
                    var tagValue = tagRow ? tagRow.querySelector('.tag-value') : null;
                    if (tagValue) tagValue.remove();
                    if (!tagItem.querySelector(':scope > .tag-children')) {
                        var childDiv = document.createElement('div');
                        childDiv.className = 'tag-children';
                        tagItem.appendChild(childDiv);
                    }
                    // Update display text
                    var nameSpan = tagRow ? tagRow.querySelector('.tag-name') : null;
                    if (nameSpan) {
                        var plcGroup = tagItem.closest('.plc-group');
                        var isManual = plcGroup && plcGroup.dataset.manualTags === 'true';
                        var displayName = tagItem.dataset.alias || getShortName(tagItem.dataset.name, isManual);
                        var display = displayName;
                        if (data.type) display += ' (' + data.type + ')';
                        display += ' [' + Object.keys(data.value).length + ' fields]';
                        nameSpan.textContent = display;
                    }
                }
            }
            callback(tagItem);
        })
        .catch(function(err) {
            console.error('Failed to read tag:', err.message);
            callback(tagItem);
        });
}

function getShortName(name, isManual) {
    if (isManual) {
        // Strip program prefix first
        if (name.indexOf('Program:') === 0) {
            var rest = name.substring(8);
            var dotIdx = rest.indexOf('.');
            if (dotIdx >= 0) name = rest.substring(dotIdx + 1);
        }
        // Strip to last dot for UDT children; top-level tags have no dots
        var idx = name.lastIndexOf('.');
        if (idx >= 0) return name.substring(idx + 1);
        return name;
    }
    // Discovery mode: strip to last segment
    var idx = name.lastIndexOf(':');
    if (idx >= 0) name = name.substring(idx + 1);
    idx = name.lastIndexOf('.');
    if (idx >= 0) name = name.substring(idx + 1);
    return name;
}

function quickTogglePublish(checkbox) {
    var tagItem = checkbox.closest('.tag-item');
    if (!tagItem) return;
    var plcGroup = checkbox.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';
    var tagName = tagItem.dataset.name;
    toggleTagEnabled(plc, tagName, checkbox.checked);
}

function handleTagClick(event, el) {
    // Don't select if clicking expand button
    if (event.target.classList.contains('tag-expand')) return;

    var tagItem = el.closest('.tag-item');
    if (!tagItem) return;

    var plcGroup = el.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';

    ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
        var memberTypes = null;
        try { memberTypes = JSON.parse(tagItem.dataset.memberTypes || 'null'); } catch (e) {}
        var info = {
            plc: plc,
            tagName: tagItem.dataset.name,
            path: '',  // root tag
            name: tagItem.dataset.name,
            type: tagItem.dataset.type,
            json: tagItem.dataset.json,
            alias: tagItem.dataset.alias,
            writable: tagItem.dataset.writable === 'true',
            enabled: tagItem.dataset.enabled === 'true',
            hasIgnores: tagItem.dataset.hasIgnores === 'true',
            ignoreCount: parseInt(tagItem.dataset.ignoreCount) || 0,
            lastPoll: tagItem.dataset.lastPoll || '',
            lastChanged: tagItem.dataset.lastChanged || '',
            memberTypes: memberTypes
        };

        selectItem(el, info);
    });
}

function handleChildClick(event, el) {
    event.stopPropagation();
    // Don't select if clicking expand button
    if (event.target.classList.contains('child-expand')) return;

    var tagItem = el.closest('.tag-item');
    var plcGroup = el.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';

    // Build path from root
    var path = el.dataset.path || buildChildPath(el);
    var childKey = el.dataset.key;
    var childType = el.dataset.type;
    var childJson = el.dataset.json;

    // Get ignore list from tag item
    var ignoreList = [];
    try {
        var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
    } catch (e) {}

    // Check if this child is independently published
    var publishedChildren = {};
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}
    var childInfo = publishedChildren[path] || {};
    var memberPublished = childInfo.enabled !== undefined ? childInfo.enabled : (childInfo === true);
    var memberWritable = childInfo.writable === true;

    var info = {
        plc: plc,
        tagName: tagItem.dataset.name,
        path: path,
        name: childKey,
        type: childType,
        json: childJson,
        alias: '',
        writable: false,
        enabled: tagItem.dataset.enabled === 'true',
        hasIgnores: false,
        ignoreCount: 0,
        ignoreList: ignoreList,
        lastPoll: tagItem.dataset.lastPoll || '',
        memberPublished: memberPublished,
        memberWritable: memberWritable
    };

    selectItem(el, info);
}

function buildChildPath(el) {
    var parts = [];
    var current = el;
    while (current) {
        if (current.classList.contains('tag-child-row') && current.dataset.key) {
            parts.unshift(current.dataset.key);
        }
        if (current.classList.contains('tag-item')) break;
        current = current.parentElement;
    }
    return parts.join('.');
}

function selectItem(el, info) {
    // Save selection
    selectedInfo = info;
    localStorage.setItem('republisher-selected-info', JSON.stringify(info));

    // Remove all selections
    document.querySelectorAll('.tag-row.selected, .tag-child-row.selected').forEach(function(row) {
        row.classList.remove('selected');
    });

    // Add selection
    el.classList.add('selected');

    // Update details panel
    updateDetailsPanel(info);
}

function toggleTagExpand(event, expandEl) {
    event.stopPropagation();
    var tagItem = expandEl.closest('.tag-item');
    if (!tagItem) return;

    var wasCollapsed = tagItem.classList.contains('collapsed');
    tagItem.classList.toggle('collapsed');

    // Build children on first expand, fetching value if needed
    if (wasCollapsed) {
        var plcGroup = tagItem.closest('.plc-group');
        var plc = plcGroup ? plcGroup.dataset.plc : '';
        ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
            buildTagChildrenFromData(tagItem);
        });
    }

    // Save expand state
    saveExpandState();
}

function buildTagChildrenIfNeeded(tagItem) {
    var childrenContainer = tagItem.querySelector(':scope > .tag-children');
    if (childrenContainer && childrenContainer.innerHTML === '') {
        var needsFetch = !tagItem.dataset.json;
        var needsMemberTypes = tagItem.dataset.isStruct === 'true' && !tagItem.dataset.memberTypes;
        if (needsFetch || needsMemberTypes) {
            var plcGroup = tagItem.closest('.plc-group');
            var plc = plcGroup ? plcGroup.dataset.plc : '';
            ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
                buildTagChildrenFromData(tagItem);
            });
            return;
        }
        buildTagChildrenFromData(tagItem);
    }
}

function buildTagChildrenFromData(tagItem) {
    var childrenContainer = tagItem.querySelector(':scope > .tag-children');
    if (!childrenContainer || childrenContainer.innerHTML !== '') return;
    var json = tagItem.dataset.json;
    if (!json) return;
    var ignoreList = [];
    var publishedChildren = {};
    var memberTypes = null;
    try {
        var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
    } catch (e) {}
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}
    try {
        memberTypes = JSON.parse(tagItem.dataset.memberTypes || 'null');
    } catch (e) {}
    try {
        var parsed = JSON.parse(json);
        if (typeof parsed === 'object' && parsed !== null) {
            childrenContainer.innerHTML = buildTagChildren(parsed, '', ignoreList, publishedChildren, memberTypes, tagItem.dataset.type);
        }
    } catch (e) {}
}

function isIgnored(path, ignoreList) {
    if (!ignoreList || ignoreList.length === 0) return false;
    for (var i = 0; i < ignoreList.length; i++) {
        if (ignoreList[i] === path) return true;
    }
    return false;
}

function isPublished(path, publishedChildren) {
    if (!publishedChildren || typeof publishedChildren !== 'object') return false;
    return publishedChildren[path] && publishedChildren[path].enabled !== false;
}

function isWritable(path, publishedChildren) {
    if (!publishedChildren || typeof publishedChildren !== 'object') return false;
    return publishedChildren[path] && publishedChildren[path].writable === true;
}

function buildTagChildren(obj, parentPath, ignoreList, publishedChildren, memberTypes, parentType) {
    var html = '';
    var isArray = Array.isArray(obj);
    var keys = isArray ? obj.map(function(_, i) { return i; }) : Object.keys(obj).sort();
    ignoreList = ignoreList || [];
    publishedChildren = publishedChildren || {};
    // For arrays, derive element type from parent type (e.g., "SINT[]" -> "SINT")
    var arrayElementType = (isArray && parentType && parentType.endsWith('[]')) ? parentType.slice(0, -2) : null;

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = obj[key];
        // Build full dot-path for memberTypes lookup (nested structs use paths like "First_Name.LEN")
        var fullKey = parentPath ? parentPath + '.' + key : String(key);
        // Use PLC member type if available (try full path first, then bare key), array element type for arrays, fall back to JS type inference
        var valueType = (memberTypes && memberTypes[fullKey]) ? memberTypes[fullKey] :
            (memberTypes && memberTypes[key]) ? memberTypes[key] :
            (isArray && arrayElementType) ? arrayElementType : getValueType(value);
        var displayKey = isArray ? '[' + key + ']' : key;
        var childPath = fullKey;
        var ignored = isIgnored(childPath, ignoreList);
        var published = isPublished(childPath, publishedChildren);
        var writable = isWritable(childPath, publishedChildren);

        // Build indicators
        var indicators = '';
        if (published) {
            indicators += '<span class="indicator indicator-publish" title="Published">P</span>';
        }
        if (writable) {
            indicators += '<span class="indicator indicator-write" title="Writable">W</span>';
        }
        if (ignored) {
            indicators += '<span class="indicator indicator-ignore" title="Ignored">I</span>';
        }

        // Primitive arrays (e.g., SINT[], DINT[]) - show inline instead of expandable
        if (Array.isArray(value) && valueType && valueType.endsWith('[]') &&
            value.length > 0 && typeof value[0] !== 'object') {
            html += '<div class="tag-child-row' + (ignored ? ' ignored' : '') + (published ? ' published' : '') + '" ' +
                'onclick="handleChildClick(event, this)" ' +
                'data-key="' + escapeAttr(String(key)) + '" ' +
                'data-path="' + escapeAttr(childPath) + '" ' +
                'data-type="' + escapeAttr(valueType) + '" ' +
                'data-json="' + escapeAttr(JSON.stringify(value)) + '">' +
                indicators +
                '<span class="child-key">' + escapeHtml(displayKey) + '</span>' +
                '<span class="child-type">(' + valueType + ')</span>' +
                '<span class="child-value">' + formatArrayInline(value) + '</span>' +
                '</div>';
            continue;
        }

        if (typeof value === 'object' && value !== null) {
            var childIsArray = Array.isArray(value);
            var count = childIsArray ? value.length : Object.keys(value).length;
            var summary = childIsArray ? '[' + count + ' items]' : '[' + count + ' fields]';

            html += '<div class="tag-child-row expandable collapsed' + (ignored ? ' ignored' : '') + (published ? ' published' : '') + '" ' +
                'onclick="handleChildClick(event, this)" ' +
                'data-key="' + escapeAttr(String(key)) + '" ' +
                'data-path="' + escapeAttr(childPath) + '" ' +
                'data-type="' + escapeAttr(valueType) + '" ' +
                'data-json="' + escapeAttr(JSON.stringify(value)) + '" ' +
                'data-ignore-list="' + escapeAttr(JSON.stringify(ignoreList)) + '" ' +
                'data-published-children="' + escapeAttr(JSON.stringify(publishedChildren)) + '">' +
                '<span class="child-expand" onclick="toggleChildExpand(event, this)">&#9660;</span>' +
                indicators +
                '<span class="child-key">' + escapeHtml(displayKey) + '</span>' +
                '<span class="child-type">(' + valueType + ')</span>' +
                '<span class="child-value">' + summary + '</span>' +
                '</div>' +
                '<div class="child-children" style="display:none"></div>';
        } else {
            html += '<div class="tag-child-row' + (ignored ? ' ignored' : '') + (published ? ' published' : '') + '" ' +
                'onclick="handleChildClick(event, this)" ' +
                'data-key="' + escapeAttr(String(key)) + '" ' +
                'data-path="' + escapeAttr(childPath) + '" ' +
                'data-type="' + escapeAttr(valueType) + '" ' +
                'data-json="' + escapeAttr(JSON.stringify(value)) + '">' +
                indicators +
                '<span class="child-key">' + escapeHtml(displayKey) + '</span>' +
                '<span class="child-type">(' + valueType + ')</span>' +
                '<span class="child-value">' + formatChildValue(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function toggleChildExpand(event, expandEl) {
    event.stopPropagation();
    var row = expandEl.closest('.tag-child-row');
    if (!row) return;

    var tagItem = row.closest('.tag-item');
    var plcGroup = row.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';
    var tagName = tagItem ? tagItem.dataset.name : '';
    var tagKey = plc + '::' + tagName;
    var path = row.dataset.path;

    var wasCollapsed = row.classList.contains('collapsed');
    row.classList.toggle('collapsed');

    var childrenContainer = row.nextElementSibling;
    if (childrenContainer && childrenContainer.classList.contains('child-children')) {
        childrenContainer.style.display = wasCollapsed ? 'block' : 'none';

        // Build children on first expand
        if (wasCollapsed && childrenContainer.innerHTML === '') {
            var json = row.dataset.json;
            var ignoreList = [];
            var publishedChildren = {};
            try {
                var parsedIgnore = JSON.parse(row.dataset.ignoreList || '[]');
                ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
            } catch (e) {}
            try {
                // Get published children from parent row or tag item
                publishedChildren = JSON.parse(row.dataset.publishedChildren || tagItem.dataset.publishedChildren || '{}');
            } catch (e) {}
            var memberTypes = null;
            try { memberTypes = JSON.parse(tagItem.dataset.memberTypes || 'null'); } catch(e) {}
            try {
                var parsed = JSON.parse(json);
                if (typeof parsed === 'object' && parsed !== null) {
                    childrenContainer.innerHTML = buildTagChildren(parsed, path, ignoreList, publishedChildren, memberTypes, row.dataset.type);
                }
            } catch (e) {}
        }
    }

    // Update expanded state directly
    var fullKey = tagKey + '::' + path;
    if (wasCollapsed) {
        // Expanding - add to state
        expandedChildren[fullKey] = true;
    } else {
        // Collapsing - remove this path AND all descendants from state
        delete expandedChildren[fullKey];
        var prefix = fullKey + '.';
        for (var key in expandedChildren) {
            if (key.indexOf(prefix) === 0) {
                delete expandedChildren[key];
            }
        }
    }
    localStorage.setItem('republisher-children-expanded', JSON.stringify(expandedChildren));
}

function saveChildExpandState() {
    // This function rebuilds the entire expanded state from the DOM
    // Only called when we need a full refresh of state
    var expanded = {};
    document.querySelectorAll('.tag-item').forEach(function(tagItem) {
        var plcGroup = tagItem.closest('.plc-group');
        if (!plcGroup) return;
        var plc = plcGroup.dataset.plc;
        var tagName = tagItem.dataset.name;
        var tagKey = plc + '::' + tagName;

        // Only save children that are visible (all ancestors are expanded)
        tagItem.querySelectorAll('.tag-child-row.expandable:not(.collapsed)').forEach(function(row) {
            var path = row.dataset.path;
            if (path && isChildVisible(row)) {
                var fullKey = tagKey + '::' + path;
                expanded[fullKey] = true;
            }
        });
    });
    localStorage.setItem('republisher-children-expanded', JSON.stringify(expanded));
    expandedChildren = expanded;
}

function isChildVisible(row) {
    // Check if all ancestor containers are visible (not inside a collapsed parent)
    var current = row.parentElement;
    while (current) {
        if (current.classList.contains('tag-item')) {
            return true; // Reached the tag item, all ancestors are visible
        }
        if (current.classList.contains('child-children')) {
            // Check if this container is hidden
            if (current.style.display === 'none') {
                return false;
            }
            // Check if the parent row is collapsed
            var parentRow = current.previousElementSibling;
            if (parentRow && parentRow.classList.contains('collapsed')) {
                return false;
            }
        }
        current = current.parentElement;
    }
    return true;
}

function formatChildValue(value) {
    if (value === null) return '<span class="text-muted">null</span>';
    if (typeof value === 'boolean') {
        return value ? '<span class="text-success">true</span>' : '<span class="text-muted">false</span>';
    }
    if (typeof value === 'string') {
        var display = value.length > 20 ? value.substring(0, 20) + '...' : value;
        return '"' + escapeHtml(display) + '"';
    }
    return String(value);
}

function formatArrayInline(arr) {
    var maxShow = 8;
    var parts = [];
    var limit = Math.min(arr.length, maxShow);
    for (var i = 0; i < limit; i++) {
        parts.push(String(arr[i]));
    }
    var result = '[' + parts.join(', ');
    if (arr.length > maxShow) {
        result += ', ... +' + (arr.length - maxShow) + ' more';
    }
    return result + '] (' + arr.length + ' items)';
}

function saveExpandState() {
    var expanded = {};
    document.querySelectorAll('.tag-item.has-children:not(.collapsed)').forEach(function(item) {
        var plc = item.closest('.plc-group').dataset.plc;
        var name = item.dataset.name;
        expanded[plc + '::' + name] = true;
    });
    localStorage.setItem('republisher-expanded', JSON.stringify(expanded));
    expandedTags = expanded;
}

function restoreChildExpandState() {
    // Iterate through all expanded tag items and restore their child states
    document.querySelectorAll('.tag-item.has-children:not(.collapsed)').forEach(function(tagItem) {
        var plcGroup = tagItem.closest('.plc-group');
        if (!plcGroup) return;
        var plc = plcGroup.dataset.plc;
        var tagName = tagItem.dataset.name;
        var tagKey = plc + '::' + tagName;

        // Get ignore list and published children for building children
        var ignoreList = [];
        var publishedChildren = {};
        try {
            var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
        } catch (e) {}
        try {
            publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
        } catch (e) {}

        // Collect all paths for this tag that should be expanded, sorted by depth
        var pathsToExpand = [];
        for (var key in expandedChildren) {
            if (key.indexOf(tagKey + '::') === 0) {
                pathsToExpand.push(key.substring(tagKey.length + 2));
            }
        }
        pathsToExpand.sort(function(a, b) {
            return a.split('.').length - b.split('.').length;
        });

        // Expand each path in order (parents first due to sorting)
        pathsToExpand.forEach(function(pathToExpand) {
            expandChildPath(tagItem, pathToExpand, ignoreList, publishedChildren);
        });
    });
}

function expandChildPath(tagItem, targetPath, ignoreList, publishedChildren) {
    // Walk through the path and ensure each level is built and expanded
    var parts = targetPath.split('.');
    var currentPath = '';
    var memberTypes = null;
    try {
        memberTypes = JSON.parse(tagItem.dataset.memberTypes || 'null');
    } catch (e) {}

    for (var i = 0; i < parts.length; i++) {
        currentPath = currentPath ? currentPath + '.' + parts[i] : parts[i];

        var row = tagItem.querySelector('.tag-child-row[data-path="' + CSS.escape(currentPath) + '"]');
        if (!row || !row.classList.contains('expandable')) {
            return; // Can't find this level, stop
        }

        var childContainer = row.nextElementSibling;
        if (!childContainer || !childContainer.classList.contains('child-children')) {
            return; // No container, stop
        }

        // Build children if not yet built
        if (childContainer.innerHTML === '') {
            var json = row.dataset.json;
            try {
                var parsed = JSON.parse(json);
                if (typeof parsed === 'object' && parsed !== null) {
                    var mt = memberTypes;
                    childContainer.innerHTML = buildTagChildren(parsed, currentPath, ignoreList, publishedChildren, mt, row.dataset.type);
                }
            } catch (e) {
                return; // Failed to build, stop
            }
        }

        // Expand this level (needed to reach deeper levels or if this is the target)
        row.classList.remove('collapsed');
        childContainer.style.display = 'block';
    }
}

function updateDetailsPanel(info) {
    var details = document.getElementById('republisher-details');

    // Save scroll position before updating
    var scrollTop = details ? details.scrollTop : 0;

    if (!info) {
        details.innerHTML = '<div class="details-placeholder">Select a tag to view details</div>';
        return;
    }

    var valueHtml = '';
    try {
        var parsed = JSON.parse(info.json);
        if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
            valueHtml = '<div class="value-tree">' + buildValueTree(parsed, '', info.memberTypes || null) + '</div>';
        } else if (Array.isArray(parsed)) {
            // Derive element type from parent type (e.g., "SINT[]" -> "SINT")
            var elType = (info.type && info.type.endsWith('[]')) ? info.type.slice(0, -2) : null;
            valueHtml = '<div class="value-tree">' + buildArrayTree(parsed, '', elType) + '</div>';
        } else {
            valueHtml = '<div class="value-simple mono">' + escapeHtml(String(parsed)) + '</div>';
        }
    } catch (e) {
        valueHtml = '<div class="value-simple mono">' + escapeHtml(info.json || '-') + '</div>';
    }

    // Check if this member is ignored
    var memberIgnored = info.path && info.ignoreList && info.ignoreList.indexOf(info.path) >= 0;

    // Build action bar with all three options
    var actionBar = '<div class="details-actions">';

    if (!info.path) {
        // Root tag controls (no Ignore Changes - that's only for child members)
        actionBar += '<label class="toggle-label" title="Publish this tag to all enabled services (MQTT, Kafka, Valkey, REST)">' +
            '<input type="checkbox" ' + (info.enabled ? 'checked' : '') +
            ' onchange="toggleTagEnabled(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', this.checked)">' +
            '<span>Published</span>' +
            '</label>' +
            '<label class="toggle-label" title="Allow writes to this tag from the API and services. This is an application-level filter and does not enable write on the PLC \u2014 it only inhibits write requests when unchecked.">' +
            '<input type="checkbox" ' + (info.writable ? 'checked' : '') +
            ' onchange="toggleTagWritable(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', this.checked)">' +
            '<span>Writable</span>' +
            '</label>';
    } else {
        // Member controls
        var memberPublished = info.memberPublished || false;
        var memberWritable = info.memberWritable || false;
        actionBar += '<label class="toggle-label" title="Publish this member as a separate tag to all enabled services (MQTT, Kafka, Valkey, REST), independent of the parent tag">' +
            '<input type="checkbox" ' + (memberPublished ? 'checked' : '') +
            ' onchange="toggleMemberEnabled(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)">' +
            '<span>Published</span>' +
            '</label>' +
            '<label class="toggle-label" title="Ignore this member for change-based republishing (useful for counters, timers, etc.). The value is still included when the parent tag republishes due to other members changing.">' +
            '<input type="checkbox" ' + (memberIgnored ? 'checked' : '') +
            ' onchange="toggleMemberIgnored(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)">' +
            '<span>Ignore Changes</span>' +
            '</label>' +
            '<label class="toggle-label" title="Allow writes to this member from the API and services. This is an application-level filter and does not enable write on the PLC \u2014 it only inhibits write requests when unchecked.">' +
            '<input type="checkbox" ' + (memberWritable ? 'checked' : '') +
            ' onchange="toggleMemberWritable(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)">' +
            '<span>Writable</span>' +
            '</label>';
    }
    actionBar += '</div>';

    // Build display name
    var displayName = info.path ? info.tagName + '.' + info.path : info.name;

    // Build write section if tag is writable
    var canWrite = (!info.path && info.writable) || (info.path && info.memberWritable);
    var writeHtml = '';
    if (canWrite) {
        var currentValue = '';
        try {
            var parsed = JSON.parse(info.json);
            if (typeof parsed !== 'object' || parsed === null) {
                currentValue = String(parsed);
            }
        } catch (e) {
            currentValue = info.json || '';
        }
        var writePath = info.path ? info.tagName + '.' + info.path : info.tagName;
        writeHtml = '<div class="write-section" style="margin-top:1rem">' +
            '<h4>Write Value</h4>' +
            '<div style="display:flex;gap:0.5rem;align-items:flex-start">' +
            '<input type="text" id="write-value-input" class="form-control" placeholder="Enter value" value="' + escapeAttr(currentValue) + '" style="flex:1" ' +
            'onkeydown="if(event.key===\'Enter\')writeTagValue(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(writePath) + '\')">' +
            '<button class="btn btn-sm" onclick="writeTagValue(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(writePath) + '\')" ' +
            'style="white-space:nowrap">Write</button>' +
            '</div>' +
            '<div id="write-result" style="margin-top:0.25rem;font-size:0.85em"></div>' +
            '</div>';
    }

    // Build tag management buttons for non-discovery PLCs
    var tagManageHtml = '';
    if (!info.path) {
        var plcGroup = document.querySelector('.plc-group[data-plc="' + escapeAttr(info.plc) + '"]');
        var isManual = plcGroup && plcGroup.dataset.manualTags === 'true';
        if (isManual) {
            tagManageHtml = '<div class="tag-manage-actions">' +
                '<button class="btn btn-sm" onclick="showEditTagModal(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(info.tagName) + '\')">Edit Tag</button>' +
                '<button class="btn btn-sm btn-danger" onclick="deleteTag(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(info.tagName) + '\')">Delete Tag</button>' +
                '</div>';
        }
    }

    details.innerHTML =
        '<div class="details-content">' +
        '<h3>' + (info.path ? 'Member Details' : 'Tag Details') + '</h3>' +
        actionBar +
        '<table class="details-table">' +
        '<tr><th>PLC</th><td>' + escapeHtml(info.plc) + '</td></tr>' +
        '<tr><th>Name</th><td class="mono">' + escapeHtml(displayName) + '</td></tr>' +
        (info.alias ? '<tr><th>Alias</th><td>' + escapeHtml(info.alias) + '</td></tr>' : '') +
        '<tr><th>Type</th><td class="mono">' + escapeHtml(info.type || '-') + '</td></tr>' +
        (info.lastPoll ? '<tr><th>Last Read</th><td>' + escapeHtml(info.lastPoll) + '</td></tr>' : '') +
        (info.lastChanged ? '<tr><th>Last Changed</th><td>' + escapeHtml(info.lastChanged) + '</td></tr>' : '') +
        (info.hasIgnores && !info.path ? '<tr><th>Ignores</th><td>' + info.ignoreCount + ' members</td></tr>' : '') +
        '</table>' +
        tagManageHtml +
        '<h4 style="margin-top:1rem">Value</h4>' +
        valueHtml +
        writeHtml +
        '</div>';

    // Restore expanded state for value tree nodes
    restoreValueTreeState();

    // Restore scroll position after browser renders
    requestAnimationFrame(function() {
        details.scrollTop = scrollTop;
    });
}

function restoreValueTreeState() {
    var details = document.getElementById('republisher-details');
    if (!details || !selectedInfo) return;

    var selectionKey = getSelectionKey();
    var expandedPaths = expandedValueNodes[selectionKey] || {};

    details.querySelectorAll('.tree-node.expandable[data-node-path]').forEach(function(node) {
        var nodePath = node.dataset.nodePath;
        if (expandedPaths[nodePath]) {
            node.classList.remove('collapsed');
            var children = node.nextElementSibling;
            if (children && children.classList.contains('tree-children')) {
                children.style.display = 'block';
            }
        }
    });
}

function escapeAttr(text) {
    if (text === null || text === undefined) return '';
    return text.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function toggleTagEnabled(plc, tagName, enabled) {
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({enabled: enabled})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and DOM immediately for responsive feedback
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc && !selectedInfo.path) {
            selectedInfo.enabled = enabled;
            updateDetailsPanel(selectedInfo);
        }
        // Update the tag row's visual state
        var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
        if (plcGroup) {
            var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
            if (tagItem) {
                tagItem.dataset.enabled = enabled;
                var tagRow = tagItem.querySelector('.tag-row');
                if (tagRow) {
                    if (enabled) {
                        tagRow.classList.add('monitored');
                    } else {
                        tagRow.classList.remove('monitored');
                    }
                    // Sync inline publish checkbox
                    var toggle = tagRow.querySelector('.publish-checkbox input');
                    if (toggle) toggle.checked = enabled;
                }
                // Update indicators
                updateTagIndicators(tagItem, tagItem.dataset.hasIgnores === 'true', tagItem.dataset.writable === 'true', enabled);
            }
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleTagWritable(plc, tagName, writable) {
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({writable: writable})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and DOM immediately
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc && !selectedInfo.path) {
            selectedInfo.writable = writable;
            updateDetailsPanel(selectedInfo);
        }
        // Update the tag item's data and indicators
        var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
        if (plcGroup) {
            var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
            if (tagItem) {
                tagItem.dataset.writable = writable;
                updateTagIndicators(tagItem, tagItem.dataset.hasIgnores === 'true', writable);
            }
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function updateTagIndicators(tagItem, hasIgnores, writable, enabled) {
    var indicators = tagItem.querySelector('.tag-indicators');
    if (indicators) {
        // Use enabled from parameter if provided, otherwise from data attribute
        var isEnabled = enabled !== undefined ? enabled : tagItem.dataset.enabled === 'true';
        var html = '';
        if (isEnabled) {
            html += '<span class="indicator indicator-publish" title="Published">P</span>';
        }
        if (hasIgnores) {
            var ignoreCount = parseInt(tagItem.dataset.ignoreCount) || 0;
            html += '<span class="indicator indicator-ignore" title="Has ' + ignoreCount + ' ignored members">I</span>';
        }
        if (writable) {
            html += '<span class="indicator indicator-write" title="Writable">W</span>';
        }
        indicators.innerHTML = html;
    }
}

function toggleTagIgnored(plc, tagName, ignored) {
    // Use "*" to indicate the entire tag is ignored
    var body = ignored ? {add_ignore: ['*']} : {remove_ignore: ['*']};
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // SSE will push the update - just update local state for immediate feedback
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc) {
            selectedInfo.hasIgnores = ignored;
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleMemberIgnored(plc, tagName, path, ignored) {
    // Build list of all published parents that need their ignore lists updated
    // For example, if path is "Position.Counter" and both "Robot1" and "Robot1.Position" are published,
    // we need to add "Position.Counter" to Robot1's ignore list and "Counter" to Robot1.Position's ignore list

    var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
    if (!plcGroup) return;
    var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
    if (!tagItem) return;

    // Get published children to find intermediate published parents
    var publishedChildren = {};
    try {
        var parsed = JSON.parse(tagItem.dataset.publishedChildren || '{}');
        publishedChildren = (typeof parsed === 'object' && parsed !== null) ? parsed : {};
    } catch (e) {}

    // Build list of API calls needed: root tag + any intermediate published parents
    var apiCalls = [];

    // 1. Always update the root tag with the full path
    apiCalls.push({
        fullTagName: tagName,
        ignorePath: path
    });

    // 2. Find any intermediate published parents and add relative paths
    var pathParts = path.split('.');
    var currentPath = '';
    for (var i = 0; i < pathParts.length - 1; i++) {
        currentPath = currentPath ? currentPath + '.' + pathParts[i] : pathParts[i];
        // Check if this intermediate path is published
        if (publishedChildren[currentPath] && publishedChildren[currentPath].enabled !== false) {
            // This intermediate path is published, add the relative path from here
            var relativePath = pathParts.slice(i + 1).join('.');
            apiCalls.push({
                fullTagName: tagName + '.' + currentPath,
                ignorePath: relativePath
            });
        }
    }

    // Execute all API calls
    var promises = apiCalls.map(function(call) {
        var body = ignored ? {add_ignore: [call.ignorePath]} : {remove_ignore: [call.ignorePath]};
        return fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(call.fullTagName), {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
        });
    });

    Promise.all(promises)
    .then(function(responses) {
        // Check if any failed
        for (var i = 0; i < responses.length; i++) {
            if (!responses[i].ok) {
                throw new Error('Failed to update ignore list');
            }
        }

        // Update local state and DOM immediately
        // Update ignore list in root tag's data attribute
        var ignoreList = [];
        try {
            var parsed = JSON.parse(tagItem.dataset.ignoreList || '[]');
            ignoreList = Array.isArray(parsed) ? parsed : [];
        } catch (e) {}

        if (ignored) {
            if (ignoreList.indexOf(path) < 0) {
                ignoreList.push(path);
            }
        } else {
            ignoreList = ignoreList.filter(function(p) { return p !== path; });
        }
        tagItem.dataset.ignoreList = JSON.stringify(ignoreList);
        tagItem.dataset.hasIgnores = ignoreList.length > 0;
        tagItem.dataset.ignoreCount = ignoreList.length;

        // Update the child row's visual state
        var childRow = tagItem.querySelector('.tag-child-row[data-path="' + path + '"]');
        if (childRow) {
            if (ignored) {
                childRow.classList.add('ignored');
            } else {
                childRow.classList.remove('ignored');
            }
            // Update ignore indicator
            var existingIndicator = childRow.querySelector('.indicator-ignore');
            if (ignored && !existingIndicator) {
                var span = document.createElement('span');
                span.className = 'indicator indicator-ignore';
                span.title = 'Ignored';
                span.textContent = 'I';
                var insertAfter = childRow.querySelector('.indicator-write') || childRow.querySelector('.indicator-publish') || childRow.querySelector('.child-expand');
                if (insertAfter) {
                    insertAfter.after(span);
                } else {
                    childRow.insertBefore(span, childRow.firstChild);
                }
            } else if (!ignored && existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Update tag indicators (to show/hide the parent's I indicator)
        updateTagIndicators(tagItem, ignoreList.length > 0, tagItem.dataset.writable === 'true');

        // Update details panel if this member is selected
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
            // Update ignoreList in selectedInfo (ensure it's an array)
            if (!Array.isArray(selectedInfo.ignoreList)) {
                selectedInfo.ignoreList = [];
            }
            if (ignored) {
                if (selectedInfo.ignoreList.indexOf(path) < 0) {
                    selectedInfo.ignoreList.push(path);
                }
            } else {
                selectedInfo.ignoreList = selectedInfo.ignoreList.filter(function(p) { return p !== path; });
            }
            updateDetailsPanel(selectedInfo);
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleMemberEnabled(plc, tagName, path, enabled) {
    // Add/update member as a separate published tag
    var fullPath = tagName + '.' + path;
    if (enabled) {
        // Create/enable the member tag
        fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({enabled: true, writable: false})
        })
        .then(function(response) {
            if (!response.ok) {
                return response.text().then(function(msg) { throw new Error(msg); });
            }
            // Update local state and details panel
            if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
                selectedInfo.memberPublished = true;
                updateDetailsPanel(selectedInfo);
            }
            // Update published children tracking and visual state
            updatePublishedChildren(plc, tagName, path, true, false);
        })
        .catch(function(err) {
            alert('Error: ' + err.message);
        });
    } else {
        // Disable the member tag
        fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({enabled: false})
        })
        .then(function(response) {
            if (!response.ok) {
                return response.text().then(function(msg) { throw new Error(msg); });
            }
            // Update local state and details panel
            if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
                selectedInfo.memberPublished = false;
                updateDetailsPanel(selectedInfo);
            }
            // Update published children tracking and visual state
            updatePublishedChildren(plc, tagName, path, false, false);
        })
        .catch(function(err) {
            alert('Error: ' + err.message);
        });
    }
}

function toggleMemberWritable(plc, tagName, path, writable) {
    // Set writable on the member path (adds as separate tag if needed, or updates existing)
    var fullPath = tagName + '.' + path;
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
        method: 'PUT',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({writable: writable, enabled: true})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and details panel
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
            selectedInfo.memberWritable = writable;
            selectedInfo.memberPublished = true;
            updateDetailsPanel(selectedInfo);
        }
        // Update published children tracking and visual state
        updatePublishedChildren(plc, tagName, path, true, writable);
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function writeTagValue(plc, tagPath) {
    var input = document.getElementById('write-value-input');
    var resultDiv = document.getElementById('write-result');
    if (!input) return;

    var rawValue = input.value;
    // Parse the value: booleans, numbers, or string
    var value;
    if (rawValue === 'true') value = true;
    else if (rawValue === 'false') value = false;
    else if (rawValue !== '' && !isNaN(Number(rawValue))) value = Number(rawValue);
    else value = rawValue;

    resultDiv.innerHTML = '<span class="text-muted">Writing...</span>';

    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagPath) + '/write', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({value: value})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        resultDiv.innerHTML = '<span class="text-success">Value written successfully</span>';
        setTimeout(function() { resultDiv.innerHTML = ''; }, 3000);
    })
    .catch(function(err) {
        resultDiv.innerHTML = '<span class="text-danger">Error: ' + escapeHtml(err.message) + '</span>';
    });
}

function updatePublishedChildren(plc, tagName, path, published, writable) {
    var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
    if (!plcGroup) return;
    var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
    if (!tagItem) return;

    // Update the published-children data attribute
    var publishedChildren = {};
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}

    if (published) {
        publishedChildren[path] = {enabled: true, writable: writable || false};
    } else {
        delete publishedChildren[path];
    }
    tagItem.dataset.publishedChildren = JSON.stringify(publishedChildren);

    // Update the child row visual state
    var childRow = tagItem.querySelector('.tag-child-row[data-path="' + path + '"]');
    if (childRow) {
        // Add/remove .published class for bold green styling
        if (published) {
            childRow.classList.add('published');
        } else {
            childRow.classList.remove('published');
        }

        // Update the published indicator
        var existingPublishIndicator = childRow.querySelector('.indicator-publish');
        if (published && !existingPublishIndicator) {
            var span = document.createElement('span');
            span.className = 'indicator indicator-publish';
            span.title = 'Published';
            span.textContent = 'P';
            // Insert after expand button if present
            var expandBtn = childRow.querySelector('.child-expand');
            if (expandBtn) {
                expandBtn.after(span);
            } else {
                childRow.insertBefore(span, childRow.firstChild);
            }
        } else if (!published && existingPublishIndicator) {
            existingPublishIndicator.remove();
        }

        // Update the writable indicator
        var existingWriteIndicator = childRow.querySelector('.indicator-write');
        if (writable && !existingWriteIndicator) {
            var wspan = document.createElement('span');
            wspan.className = 'indicator indicator-write';
            wspan.title = 'Writable';
            wspan.textContent = 'W';
            // Insert after publish indicator or expand button
            var insertAfter = childRow.querySelector('.indicator-publish') || childRow.querySelector('.child-expand');
            if (insertAfter) {
                insertAfter.after(wspan);
            } else {
                childRow.insertBefore(wspan, childRow.firstChild);
            }
        } else if (!writable && existingWriteIndicator) {
            existingWriteIndicator.remove();
        }
    }
}

function buildValueTree(obj, parentPath, memberTypes) {
    var html = '';
    var keys = Object.keys(obj).sort();

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = obj[key];
        var fullKey = parentPath ? parentPath + '.' + key : key;
        var valueType = (memberTypes && memberTypes[fullKey]) ? memberTypes[fullKey] :
            (memberTypes && memberTypes[key]) ? memberTypes[key] : getValueType(value);
        var nodePath = fullKey;

        if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                // Primitive arrays with known type - show inline
                if (valueType && valueType.endsWith('[]') && value.length > 0 && typeof value[0] !== 'object') {
                    html += '<div class="tree-node">' +
                        '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                        '<span class="tree-type">(' + valueType + ')</span>' +
                        '<span class="tree-value">' + formatArrayInline(value) + '</span>' +
                        '</div>';
                } else {
                    // Array - derive element type by stripping [] from this member's type
                    var arrElType = (valueType && valueType.endsWith('[]')) ? valueType.slice(0, -2) : null;
                    html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                        '<span class="tree-expand">&#9660;</span>' +
                        '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                        '<span class="tree-type">(' + valueType + ')</span>' +
                        '<span class="tree-summary">[' + value.length + ' items]</span>' +
                        '</div>' +
                        '<div class="tree-children" style="display:none">' + buildArrayTree(value, nodePath, arrElType) + '</div>';
                }
            } else {
                // Nested object
                var fieldCount = Object.keys(value).length;
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                    '<span class="tree-type">(' + valueType + ')</span>' +
                    '<span class="tree-summary">[' + fieldCount + ' fields]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildValueTree(value, nodePath, memberTypes) + '</div>';
            }
        } else {
            // Primitive value
            html += '<div class="tree-node">' +
                '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                '<span class="tree-type">(' + valueType + ')</span>' +
                '<span class="tree-value">' + formatPrimitive(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function buildArrayTree(arr, parentPath, elementType) {
    var html = '';
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        var valueType = elementType || getValueType(value);
        var nodePath = parentPath ? parentPath + '[' + i + ']' : '[' + i + ']';

        if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">[' + i + ']</span>' +
                    '<span class="tree-type">(Array)</span>' +
                    '<span class="tree-summary">[' + value.length + ' items]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildArrayTree(value, nodePath) + '</div>';
            } else {
                var fieldCount = Object.keys(value).length;
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">[' + i + ']</span>' +
                    '<span class="tree-type">(' + valueType + ')</span>' +
                    '<span class="tree-summary">[' + fieldCount + ' fields]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildValueTree(value, nodePath) + '</div>';
            }
        } else {
            html += '<div class="tree-node">' +
                '<span class="tree-key">[' + i + ']</span>' +
                '<span class="tree-type">(' + valueType + ')</span>' +
                '<span class="tree-value">' + formatPrimitive(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function getValueType(value) {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'Array';
    if (typeof value === 'object') return 'Object';
    if (typeof value === 'boolean') return 'BOOL';
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'INT' : 'REAL';
    }
    if (typeof value === 'string') return 'STRING';
    return typeof value;
}

function formatPrimitive(value) {
    if (value === null) return '<span class="text-muted">null</span>';
    if (typeof value === 'boolean') {
        return '<span class="text-' + (value ? 'success' : 'muted') + '">' + value + '</span>';
    }
    if (typeof value === 'number') {
        return '<span class="text-primary">' + value + '</span>';
    }
    if (typeof value === 'string') {
        return '<span class="text-string">"' + escapeHtml(value) + '"</span>';
    }
    return escapeHtml(String(value));
}

function toggleTreeNode(event, el) {
    event.stopPropagation();
    var children = el.nextElementSibling;
    if (children && children.classList.contains('tree-children')) {
        var isCollapsed = el.classList.contains('collapsed');
        el.classList.toggle('collapsed');
        children.style.display = isCollapsed ? 'block' : 'none';

        // Save expanded state scoped to current selection
        var nodePath = el.dataset.nodePath;
        if (nodePath && selectedInfo) {
            var selectionKey = getSelectionKey();
            if (!expandedValueNodes[selectionKey]) {
                expandedValueNodes[selectionKey] = {};
            }
            if (isCollapsed) {
                expandedValueNodes[selectionKey][nodePath] = true;
            } else {
                delete expandedValueNodes[selectionKey][nodePath];
            }
            localStorage.setItem('republisher-value-expanded', JSON.stringify(expandedValueNodes));
        }
    }
}

function getSelectionKey() {
    if (!selectedInfo) return '';
    return selectedInfo.plc + '::' + selectedInfo.tagName + (selectedInfo.path ? '::' + selectedInfo.path : '');
}


function toggleSection(el) {
    var sectionGroup = el.closest('.section-group');
    var plcGroup = el.closest('.plc-group');
    var plcName = plcGroup ? plcGroup.dataset.plc : '';
    var sectionName = sectionGroup.dataset.section;
    var key = plcName + '::' + sectionName;

    sectionGroup.classList.toggle('collapsed');

    // Save collapsed state
    if (sectionGroup.classList.contains('collapsed')) {
        collapsedSections[key] = true;
    } else {
        delete collapsedSections[key];
    }
    localStorage.setItem('republisher-sections-collapsed', JSON.stringify(collapsedSections));
}

function initPLCSelector() {
    var selector = document.getElementById('plc-selector');
    if (!selector) return;

    var groups = document.querySelectorAll('.plc-group');
    if (groups.length === 0) {
        selector.style.display = 'none';
        return;
    }

    selector.style.display = '';
    selector.innerHTML = '';

    // If only one PLC, hide selector and show it
    if (groups.length === 1) {
        selector.style.display = 'none';
        groups[0].style.display = '';
        selectedPLC = groups[0].dataset.plc;
        return;
    }

    // Validate saved selection still exists
    var savedExists = false;
    groups.forEach(function(g) {
        if (g.dataset.plc === selectedPLC) savedExists = true;
    });
    if (!savedExists) {
        selectedPLC = groups[0].dataset.plc;
    }

    // Build plc-picker dropdown
    var picker = document.createElement('div');
    picker.className = 'plc-picker';
    picker.id = 'plc-picker';

    var display = document.createElement('div');
    display.className = 'plc-picker-display';
    display.id = 'plc-picker-display';
    display.setAttribute('tabindex', '0');
    display.onclick = function(e) { e.stopPropagation(); togglePLCPicker(); };
    picker.appendChild(display);

    var dropdown = document.createElement('div');
    dropdown.className = 'plc-picker-dropdown';
    dropdown.id = 'plc-picker-dropdown';
    dropdown.style.display = 'none';
    dropdown.onclick = function(e) { e.stopPropagation(); };

    var filter = document.createElement('input');
    filter.className = 'plc-picker-filter';
    filter.id = 'plc-picker-filter';
    filter.type = 'text';
    filter.placeholder = 'Search PLCs...';
    filter.setAttribute('autocomplete', 'off');
    dropdown.appendChild(filter);

    var list = document.createElement('div');
    list.className = 'plc-picker-list';
    list.id = 'plc-picker-list';
    dropdown.appendChild(list);

    var status = document.createElement('div');
    status.className = 'plc-picker-status';
    status.id = 'plc-picker-status';
    status.textContent = groups.length + ' PLCs';
    dropdown.appendChild(status);

    picker.appendChild(dropdown);
    selector.appendChild(picker);

    // Build items
    buildPLCPickerItems();

    // Update display for current selection
    updatePLCPickerDisplay();

    // Filter input handler
    filter.addEventListener('input', function() {
        filterPLCPicker(this.value);
    });

    // Keyboard handler
    filter.addEventListener('keydown', handlePLCPickerKeydown);
    display.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
            e.preventDefault();
            togglePLCPicker();
        }
    });

    // Click outside closes
    document.addEventListener('click', function() {
        closePLCPicker();
    });

    // Show/hide PLC groups based on selection
    groups.forEach(function(group) {
        group.style.display = (group.dataset.plc === selectedPLC) ? '' : 'none';
    });

    localStorage.setItem('republisher-selected-plc', selectedPLC);
}

function buildPLCPickerItems() {
    var list = document.getElementById('plc-picker-list');
    if (!list) return;
    list.innerHTML = '';
    var groups = document.querySelectorAll('.plc-group');
    groups.forEach(function(group) {
        var plcName = group.dataset.plc;
        var statusDot = group.querySelector('.plc-header-bar .status-dot');
        var statusClass = statusDot ? statusDot.className.replace('status-dot', '').trim() : '';
        var tagCountEl = group.querySelector('.plc-header-bar .tag-count');
        var tagCount = tagCountEl ? tagCountEl.textContent : '0 tags';
        var addressEl = group.querySelector('.plc-header-bar .plc-detail');
        var address = addressEl ? addressEl.textContent : '';

        var item = document.createElement('div');
        item.className = 'plc-picker-item' + (plcName === selectedPLC ? ' current' : '');
        item.dataset.plc = plcName;
        item.dataset.address = address;
        item.onclick = function() { selectPLC(plcName); };
        item.innerHTML = '<span class="status-dot ' + statusClass + '"></span>' +
            '<span class="plc-picker-item-name">' + escapeHtml(plcName) + '</span>' +
            '<span class="plc-picker-item-detail">' + escapeHtml(address) + '</span>' +
            '<span class="plc-picker-item-count">' + escapeHtml(tagCount) + '</span>';
        list.appendChild(item);
    });
}

function updatePLCPickerDisplay() {
    var display = document.getElementById('plc-picker-display');
    if (!display) return;
    var group = document.querySelector('.plc-group[data-plc="' + CSS.escape(selectedPLC) + '"]');
    var statusClass = '';
    if (group) {
        var dot = group.querySelector('.plc-header-bar .status-dot');
        statusClass = dot ? dot.className.replace('status-dot', '').trim() : '';
    }
    display.innerHTML = '<span class="status-dot ' + statusClass + '"></span>' +
        '<span class="plc-picker-display-text">' + escapeHtml(selectedPLC) + '</span>' +
        '<span class="plc-picker-arrow">&#9660;</span>';
}

function togglePLCPicker() {
    var picker = document.getElementById('plc-picker');
    var dropdown = document.getElementById('plc-picker-dropdown');
    var filter = document.getElementById('plc-picker-filter');
    if (!picker || !dropdown) return;

    var isOpen = picker.classList.contains('open');
    if (isOpen) {
        closePLCPicker();
    } else {
        picker.classList.add('open');
        dropdown.style.display = '';
        filter.value = '';
        filterPLCPicker('');
        filter.focus();
        // Ensure current item is highlighted
        var list = document.getElementById('plc-picker-list');
        if (list) {
            list.querySelectorAll('.plc-picker-item').forEach(function(item) {
                item.classList.remove('highlighted');
            });
            var current = list.querySelector('.plc-picker-item.current');
            if (current) {
                current.classList.add('highlighted');
                current.scrollIntoView({ block: 'nearest' });
            }
        }
    }
}

function closePLCPicker() {
    var picker = document.getElementById('plc-picker');
    var dropdown = document.getElementById('plc-picker-dropdown');
    if (!picker || !dropdown) return;
    picker.classList.remove('open');
    dropdown.style.display = 'none';
}

function filterPLCPicker(query) {
    var list = document.getElementById('plc-picker-list');
    var status = document.getElementById('plc-picker-status');
    if (!list) return;
    var q = query.toLowerCase();
    var visible = 0;
    var items = list.querySelectorAll('.plc-picker-item');
    items.forEach(function(item) {
        var name = (item.dataset.plc || '').toLowerCase();
        var addr = (item.dataset.address || '').toLowerCase();
        var match = !q || name.indexOf(q) >= 0 || addr.indexOf(q) >= 0;
        item.style.display = match ? '' : 'none';
        if (match) visible++;
    });
    if (status) {
        status.textContent = visible + ' of ' + items.length + ' PLCs';
    }
    // Highlight first visible if nothing highlighted
    var highlighted = list.querySelector('.plc-picker-item.highlighted:not([style*="display: none"])');
    if (!highlighted) {
        var first = list.querySelector('.plc-picker-item:not([style*="display: none"])');
        if (first) first.classList.add('highlighted');
    }
}

function handlePLCPickerKeydown(e) {
    var list = document.getElementById('plc-picker-list');
    if (!list) return;
    var items = Array.from(list.querySelectorAll('.plc-picker-item:not([style*="display: none"])'));
    if (items.length === 0) return;

    var currentIdx = -1;
    items.forEach(function(item, i) {
        if (item.classList.contains('highlighted')) currentIdx = i;
    });

    if (e.key === 'ArrowDown') {
        e.preventDefault();
        var nextIdx = currentIdx < items.length - 1 ? currentIdx + 1 : 0;
        items.forEach(function(item) { item.classList.remove('highlighted'); });
        items[nextIdx].classList.add('highlighted');
        items[nextIdx].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        var prevIdx = currentIdx > 0 ? currentIdx - 1 : items.length - 1;
        items.forEach(function(item) { item.classList.remove('highlighted'); });
        items[prevIdx].classList.add('highlighted');
        items[prevIdx].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'Enter') {
        e.preventDefault();
        var highlighted = items[currentIdx >= 0 ? currentIdx : 0];
        if (highlighted) {
            selectPLC(highlighted.dataset.plc);
        }
    } else if (e.key === 'Escape') {
        e.preventDefault();
        closePLCPicker();
        var display = document.getElementById('plc-picker-display');
        if (display) display.focus();
    }
}

function selectPLC(plcName) {
    selectedPLC = plcName;
    localStorage.setItem('republisher-selected-plc', plcName);

    // Update picker display and items
    updatePLCPickerDisplay();
    var list = document.getElementById('plc-picker-list');
    if (list) {
        list.querySelectorAll('.plc-picker-item').forEach(function(item) {
            item.classList.toggle('current', item.dataset.plc === plcName);
        });
    }
    closePLCPicker();

    // Show/hide PLC groups
    document.querySelectorAll('.plc-group').forEach(function(group) {
        group.style.display = (group.dataset.plc === plcName) ? '' : 'none';
    });
}

function restoreState() {
    // Initialize PLC selector
    initPLCSelector();

    // Restore section collapsed state
    document.querySelectorAll('.section-group').forEach(function(section) {
        var plcGroup = section.closest('.plc-group');
        var plcName = plcGroup ? plcGroup.dataset.plc : '';
        var sectionName = section.dataset.section;
        var key = plcName + '::' + sectionName;
        if (collapsedSections[key]) {
            section.classList.add('collapsed');
        }
    });

    // Restore tag expanded state and build children
    document.querySelectorAll('.tag-item.has-children').forEach(function(item) {
        var plc = item.closest('.plc-group').dataset.plc;
        var name = item.dataset.name;
        var key = plc + '::' + name;
        if (expandedTags[key]) {
            item.classList.remove('collapsed');
            buildTagChildrenIfNeeded(item);
        }
    });

    // Restore child expanded state
    restoreChildExpandState();

    // Restore selection
    if (selectedInfo && selectedInfo.plc && selectedInfo.tagName) {
        var tagItem = document.querySelector(
            '.plc-group[data-plc="' + selectedInfo.plc + '"] .tag-item[data-name="' + selectedInfo.tagName + '"]'
        );

        if (tagItem) {
            // Update the stored data from current DOM
            selectedInfo.json = tagItem.dataset.json;
            selectedInfo.type = tagItem.dataset.type;
            selectedInfo.enabled = tagItem.dataset.enabled === 'true';
            selectedInfo.writable = tagItem.dataset.writable === 'true';
            selectedInfo.hasIgnores = tagItem.dataset.hasIgnores === 'true';
            selectedInfo.ignoreCount = parseInt(tagItem.dataset.ignoreCount) || 0;
            selectedInfo.lastPoll = tagItem.dataset.lastPoll || '';
            selectedInfo.lastChanged = tagItem.dataset.lastChanged || '';

            // Get ignore list and published children from tag item
            var ignoreList = [];
            var publishedChildren = {};
            try {
                var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
            } catch (e) {}
            try {
                publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
            } catch (e) {}
            selectedInfo.ignoreList = ignoreList;

            if (selectedInfo.path) {
                // Child was selected - need to expand parent and find child
                tagItem.classList.remove('collapsed');
                buildTagChildrenIfNeeded(tagItem);

                // Expand all intermediate nodes in the path
                var memberTypes = null;
                try {
                    memberTypes = JSON.parse(tagItem.dataset.memberTypes || 'null');
                } catch (e) {}
                var pathParts = selectedInfo.path.split('.');
                var currentPath = '';
                for (var i = 0; i < pathParts.length - 1; i++) {
                    currentPath = currentPath ? currentPath + '.' + pathParts[i] : pathParts[i];
                    var parentRow = tagItem.querySelector('.tag-child-row[data-path="' + currentPath + '"]');
                    if (parentRow && parentRow.classList.contains('expandable')) {
                        parentRow.classList.remove('collapsed');
                        var childContainer = parentRow.nextElementSibling;
                        if (childContainer && childContainer.classList.contains('child-children')) {
                            childContainer.style.display = 'block';
                            if (childContainer.innerHTML === '') {
                                var json = parentRow.dataset.json;
                                try {
                                    var parsed = JSON.parse(json);
                                    if (typeof parsed === 'object' && parsed !== null) {
                                        var mt = memberTypes;
                                        childContainer.innerHTML = buildTagChildren(parsed, currentPath, ignoreList, publishedChildren, mt, parentRow.dataset.type);
                                    }
                                } catch (e) {}
                            }
                        }
                    }
                }

                // Update the JSON value for selected child
                try {
                    var parsed = JSON.parse(tagItem.dataset.json);
                    for (var i = 0; i < pathParts.length; i++) {
                        if (parsed && typeof parsed === 'object') {
                            parsed = parsed[pathParts[i]];
                        }
                    }
                    if (parsed !== undefined) {
                        selectedInfo.json = JSON.stringify(parsed);
                        selectedInfo.type = getValueType(parsed);
                    }
                } catch (e) {}

                // Update published/writable state for the selected child
                var childInfo = publishedChildren[selectedInfo.path] || {};
                selectedInfo.memberPublished = childInfo.enabled !== undefined ? childInfo.enabled : (childInfo === true);
                selectedInfo.memberWritable = childInfo.writable === true;

                // Find and select the child row
                var childRow = tagItem.querySelector('.tag-child-row[data-path="' + selectedInfo.path + '"]');
                if (childRow) {
                    childRow.classList.add('selected');
                }
            } else {
                // Root tag was selected
                var tagRow = tagItem.querySelector('.tag-row');
                if (tagRow) {
                    tagRow.classList.add('selected');
                }
            }

            // Update details - scroll is preserved inside updateDetailsPanel
            updateDetailsPanel(selectedInfo);
        }
    }
}

function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// --- Tag Management (Add/Edit/Delete for non-discovery PLCs) ---

function showAddTagModal(plcName) {
    document.getElementById('tag-modal-plc').value = plcName;
    document.getElementById('tag-modal-mode').value = 'add';
    document.getElementById('tag-modal-original-name').value = '';
    document.getElementById('tag-modal-title').textContent = 'Add Tag';
    document.getElementById('tag-modal-submit').textContent = 'Add Tag';

    fetch('/htmx/plcs/' + encodeURIComponent(plcName) + '/types')
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            return resp.json();
        })
        .then(function(data) {
            buildTagModalFields(data, null);
            WarLink.showModal('tag-modal');
        })
        .catch(function(err) {
            alert('Error loading PLC type info: ' + err.message);
        });
}

function showEditTagModal(plcName, tagName) {
    document.getElementById('tag-modal-plc').value = plcName;
    document.getElementById('tag-modal-mode').value = 'edit';
    document.getElementById('tag-modal-original-name').value = tagName;
    document.getElementById('tag-modal-title').textContent = 'Edit Tag';
    document.getElementById('tag-modal-submit').textContent = 'Save';

    // Get current tag data from the DOM
    var plcGroup = document.querySelector('.plc-group[data-plc="' + plcName + '"]');
    var tagItem = plcGroup ? plcGroup.querySelector('.tag-item[data-name="' + CSS.escape(tagName) + '"]') : null;
    var existing = null;
    if (tagItem) {
        existing = {
            name: tagItem.dataset.name,
            type: tagItem.dataset.type || '',
            alias: tagItem.dataset.alias || '',
            writable: tagItem.dataset.writable === 'true'
        };
    }

    fetch('/htmx/plcs/' + encodeURIComponent(plcName) + '/types')
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            return resp.json();
        })
        .then(function(data) {
            buildTagModalFields(data, existing);
            WarLink.showModal('tag-modal');
        })
        .catch(function(err) {
            alert('Error loading PLC type info: ' + err.message);
        });
}

function buildTagModalFields(typeInfo, existing) {
    var container = document.getElementById('tag-modal-fields');
    var isAddressBased = typeInfo.address_based;
    var addressLabel = typeInfo.address_label;
    var types = typeInfo.types || [];

    // Build type options HTML
    var defaultIdx = 3; // DINT default
    var typeOptionsHtml = '';
    for (var i = 0; i < types.length; i++) {
        var selected = '';
        if (existing && existing.type) {
            if (types[i] === existing.type) selected = ' selected';
        } else if (i === defaultIdx) {
            selected = ' selected';
        }
        typeOptionsHtml += '<option value="' + escapeAttr(types[i]) + '"' + selected + '>' + escapeHtml(types[i]) + '</option>';
    }

    var nameValue = existing ? escapeAttr(existing.name) : '';
    var aliasValue = existing ? escapeAttr(existing.alias) : '';
    var writableChecked = existing && existing.writable ? ' checked' : '';

    var html = '';
    if (isAddressBased) {
        // Address-based: Alias first, then Type, then Address
        html += '<div class="form-group"><label>Alias</label><input type="text" class="form-control" id="tag-modal-alias" value="' + aliasValue + '" placeholder="Optional display name"></div>';
        html += '<div class="form-group"><label>Data Type</label><select class="form-control" id="tag-modal-type">' + typeOptionsHtml + '</select></div>';
        html += '<div class="form-group"><label>' + escapeHtml(addressLabel) + '</label><input type="text" class="form-control" id="tag-modal-name" value="' + nameValue + '" required placeholder="e.g. ' + (addressLabel === 'DB.Offset' ? 'DB1.DBD0' : 'DM100') + '"></div>';
    } else {
        // Tag-based: Tag Name, Type, Alias
        html += '<div class="form-group"><label>' + escapeHtml(addressLabel) + '</label><input type="text" class="form-control" id="tag-modal-name" value="' + nameValue + '" required></div>';
        html += '<div class="form-group"><label>Data Type</label><select class="form-control" id="tag-modal-type">' + typeOptionsHtml + '</select></div>';
        html += '<div class="form-group"><label>Alias</label><input type="text" class="form-control" id="tag-modal-alias" value="' + aliasValue + '" placeholder="Optional display name"></div>';
    }
    html += '<div class="form-group"><label class="toggle-label"><input type="checkbox" id="tag-modal-writable"' + writableChecked + '> <span>Writable</span></label></div>';

    container.innerHTML = html;
}

function submitTagModal(event) {
    event.preventDefault();

    var plcName = document.getElementById('tag-modal-plc').value;
    var mode = document.getElementById('tag-modal-mode').value;
    var originalName = document.getElementById('tag-modal-original-name').value;
    var tagName = document.getElementById('tag-modal-name').value.trim();
    var dataType = document.getElementById('tag-modal-type').value;
    var alias = document.getElementById('tag-modal-alias').value.trim();
    var writable = document.getElementById('tag-modal-writable').checked;

    if (!tagName) {
        alert('Tag name/address is required');
        return;
    }

    // For edit mode, if name changed, delete the old tag first
    var deleteOld = mode === 'edit' && originalName && originalName !== tagName;

    function doSave() {
        fetch('/htmx/tags/' + encodeURIComponent(plcName) + '/' + encodeURIComponent(tagName), {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                enabled: true,
                writable: writable,
                data_type: dataType,
                alias: alias
            })
        })
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            WarLink.hideModal('tag-modal');
        })
        .catch(function(err) {
            alert('Error saving tag: ' + err.message);
        });
    }

    if (deleteOld) {
        fetch('/htmx/tags/' + encodeURIComponent(plcName) + '/' + encodeURIComponent(originalName), {
            method: 'DELETE'
        })
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            doSave();
        })
        .catch(function(err) {
            alert('Error removing old tag: ' + err.message);
        });
    } else {
        doSave();
    }
}

function deleteTag(plcName, tagName) {
    if (!confirm('Delete tag "' + tagName + '"?')) return;

    fetch('/htmx/tags/' + encodeURIComponent(plcName) + '/' + encodeURIComponent(tagName), {
        method: 'DELETE'
    })
    .then(function(resp) {
        if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
        // Clear selection if the deleted tag was selected
        if (selectedInfo && selectedInfo.plc === plcName && selectedInfo.tagName === tagName) {
            selectedInfo = null;
            localStorage.removeItem('republisher-selected-info');
            document.getElementById('republisher-details').innerHTML = '<div class="details-placeholder">Select a tag to view details</div>';
        }
    })
    .catch(function(err) {
        alert('Error deleting tag: ' + err.message);
    });
}

// Restore state on initial load
document.addEventListener('DOMContentLoaded', restoreState);
</script>
<script src="/static/js/sse-events.js"></script>

{{template "footer" .}}

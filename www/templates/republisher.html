{{template "header" .}}

<div class="page-header">
    <h1>Republisher</h1>
</div>

<div class="republisher-layout">
    <div class="republisher-tree" id="republisher-tree">
        {{template "republisher_tree.html" .}}
    </div>
    <div class="republisher-details" id="republisher-details">
        <div class="details-placeholder">
            Select a tag to view details
        </div>
    </div>
</div>

<script>
// Store state in localStorage
var collapsedPLCs = JSON.parse(localStorage.getItem('republisher-collapsed') || '{}');
var collapsedSections = JSON.parse(localStorage.getItem('republisher-sections-collapsed') || '{}');
var expandedTags = JSON.parse(localStorage.getItem('republisher-expanded') || '{}');
var expandedChildren = JSON.parse(localStorage.getItem('republisher-children-expanded') || '{}');
var selectedInfo = JSON.parse(localStorage.getItem('republisher-selected-info') || 'null');
var expandedValueNodes = JSON.parse(localStorage.getItem('republisher-value-expanded') || '{}');

// Fetch a tag's value on demand if not already cached in the DOM.
// Calls callback(tagItem) after the value is available.
function ensureTagValue(plc, tagName, tagItem, callback) {
    if (tagItem.dataset.json) {
        callback(tagItem);
        return;
    }
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName))
        .then(function(resp) {
            if (!resp.ok) return resp.text().then(function(msg) { throw new Error(msg); });
            return resp.json();
        })
        .then(function(data) {
            var jsonValue = JSON.stringify(data.value);
            tagItem.dataset.json = jsonValue;
            if (data.type) tagItem.dataset.type = data.type;

            // Upgrade to struct if value is an object
            var isStruct = data.value !== null && typeof data.value === 'object' && !Array.isArray(data.value);
            if (isStruct && !tagItem.classList.contains('has-children')) {
                tagItem.classList.add('has-children', 'collapsed');
                tagItem.dataset.isStruct = 'true';
                tagItem.dataset.fieldCount = String(Object.keys(data.value).length);
                var tagRow = tagItem.querySelector('.tag-row');
                if (tagRow && !tagRow.querySelector('.tag-expand')) {
                    var expandSpan = document.createElement('span');
                    expandSpan.className = 'tag-expand';
                    expandSpan.innerHTML = '&#9660;';
                    expandSpan.setAttribute('onclick', 'toggleTagExpand(event, this)');
                    tagRow.insertBefore(expandSpan, tagRow.firstChild);
                }
                var tagValue = tagRow ? tagRow.querySelector('.tag-value') : null;
                if (tagValue) tagValue.remove();
                if (!tagItem.querySelector(':scope > .tag-children')) {
                    var childDiv = document.createElement('div');
                    childDiv.className = 'tag-children';
                    tagItem.appendChild(childDiv);
                }
                // Update display text
                var nameSpan = tagRow ? tagRow.querySelector('.tag-name') : null;
                if (nameSpan) {
                    var displayName = tagItem.dataset.alias || getShortName(tagItem.dataset.name);
                    var display = displayName;
                    if (data.type) display += ' (' + data.type + ')';
                    display += ' [' + Object.keys(data.value).length + ' fields]';
                    nameSpan.textContent = display;
                }
            }
            callback(tagItem);
        })
        .catch(function(err) {
            console.error('Failed to read tag:', err.message);
            callback(tagItem);
        });
}

function getShortName(name) {
    var idx = name.lastIndexOf(':');
    if (idx >= 0) name = name.substring(idx + 1);
    idx = name.lastIndexOf('.');
    if (idx >= 0) name = name.substring(idx + 1);
    return name;
}

function handleTagClick(event, el) {
    // Don't select if clicking expand button
    if (event.target.classList.contains('tag-expand')) return;

    var tagItem = el.closest('.tag-item');
    if (!tagItem) return;

    var plcGroup = el.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';

    ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
        var info = {
            plc: plc,
            tagName: tagItem.dataset.name,
            path: '',  // root tag
            name: tagItem.dataset.name,
            type: tagItem.dataset.type,
            json: tagItem.dataset.json,
            alias: tagItem.dataset.alias,
            writable: tagItem.dataset.writable === 'true',
            enabled: tagItem.dataset.enabled === 'true',
            hasIgnores: tagItem.dataset.hasIgnores === 'true',
            ignoreCount: parseInt(tagItem.dataset.ignoreCount) || 0,
            lastPoll: tagItem.dataset.lastPoll || '',
            lastChanged: tagItem.dataset.lastChanged || ''
        };

        selectItem(el, info);
    });
}

function handleChildClick(event, el) {
    event.stopPropagation();
    // Don't select if clicking expand button
    if (event.target.classList.contains('child-expand')) return;

    var tagItem = el.closest('.tag-item');
    var plcGroup = el.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';

    // Build path from root
    var path = el.dataset.path || buildChildPath(el);
    var childKey = el.dataset.key;
    var childType = el.dataset.type;
    var childJson = el.dataset.json;

    // Get ignore list from tag item
    var ignoreList = [];
    try {
        var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
    } catch (e) {}

    // Check if this child is independently published
    var publishedChildren = {};
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}
    var childInfo = publishedChildren[path] || {};
    var memberPublished = childInfo.enabled !== undefined ? childInfo.enabled : (childInfo === true);
    var memberWritable = childInfo.writable === true;

    var info = {
        plc: plc,
        tagName: tagItem.dataset.name,
        path: path,
        name: childKey,
        type: childType,
        json: childJson,
        alias: '',
        writable: false,
        enabled: tagItem.dataset.enabled === 'true',
        hasIgnores: false,
        ignoreCount: 0,
        ignoreList: ignoreList,
        lastPoll: tagItem.dataset.lastPoll || '',
        memberPublished: memberPublished,
        memberWritable: memberWritable
    };

    selectItem(el, info);
}

function buildChildPath(el) {
    var parts = [];
    var current = el;
    while (current) {
        if (current.classList.contains('tag-child-row') && current.dataset.key) {
            parts.unshift(current.dataset.key);
        }
        if (current.classList.contains('tag-item')) break;
        current = current.parentElement;
    }
    return parts.join('.');
}

function selectItem(el, info) {
    // Save selection
    selectedInfo = info;
    localStorage.setItem('republisher-selected-info', JSON.stringify(info));

    // Remove all selections
    document.querySelectorAll('.tag-row.selected, .tag-child-row.selected').forEach(function(row) {
        row.classList.remove('selected');
    });

    // Add selection
    el.classList.add('selected');

    // Update details panel
    updateDetailsPanel(info);
}

function toggleTagExpand(event, expandEl) {
    event.stopPropagation();
    var tagItem = expandEl.closest('.tag-item');
    if (!tagItem) return;

    var wasCollapsed = tagItem.classList.contains('collapsed');
    tagItem.classList.toggle('collapsed');

    // Build children on first expand, fetching value if needed
    if (wasCollapsed) {
        var plcGroup = tagItem.closest('.plc-group');
        var plc = plcGroup ? plcGroup.dataset.plc : '';
        ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
            buildTagChildrenFromData(tagItem);
        });
    }

    // Save expand state
    saveExpandState();
}

function buildTagChildrenIfNeeded(tagItem) {
    var childrenContainer = tagItem.querySelector(':scope > .tag-children');
    if (childrenContainer && childrenContainer.innerHTML === '') {
        if (!tagItem.dataset.json) {
            // No data yet â€” fetch it
            var plcGroup = tagItem.closest('.plc-group');
            var plc = plcGroup ? plcGroup.dataset.plc : '';
            ensureTagValue(plc, tagItem.dataset.name, tagItem, function() {
                buildTagChildrenFromData(tagItem);
            });
            return;
        }
        buildTagChildrenFromData(tagItem);
    }
}

function buildTagChildrenFromData(tagItem) {
    var childrenContainer = tagItem.querySelector(':scope > .tag-children');
    if (!childrenContainer || childrenContainer.innerHTML !== '') return;
    var json = tagItem.dataset.json;
    if (!json) return;
    var ignoreList = [];
    var publishedChildren = {};
    try {
        var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
    } catch (e) {}
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}
    try {
        var parsed = JSON.parse(json);
        if (typeof parsed === 'object' && parsed !== null) {
            childrenContainer.innerHTML = buildTagChildren(parsed, '', ignoreList, publishedChildren);
        }
    } catch (e) {}
}

function isIgnored(path, ignoreList) {
    if (!ignoreList || ignoreList.length === 0) return false;
    for (var i = 0; i < ignoreList.length; i++) {
        if (ignoreList[i] === path) return true;
    }
    return false;
}

function isPublished(path, publishedChildren) {
    if (!publishedChildren || typeof publishedChildren !== 'object') return false;
    return publishedChildren[path] && publishedChildren[path].enabled !== false;
}

function isWritable(path, publishedChildren) {
    if (!publishedChildren || typeof publishedChildren !== 'object') return false;
    return publishedChildren[path] && publishedChildren[path].writable === true;
}

function buildTagChildren(obj, parentPath, ignoreList, publishedChildren) {
    var html = '';
    var isArray = Array.isArray(obj);
    var keys = isArray ? obj.map(function(_, i) { return i; }) : Object.keys(obj).sort();
    ignoreList = ignoreList || [];
    publishedChildren = publishedChildren || {};

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = obj[key];
        var valueType = getValueType(value);
        var displayKey = isArray ? '[' + key + ']' : key;
        var childPath = parentPath ? parentPath + '.' + key : String(key);
        var ignored = isIgnored(childPath, ignoreList);
        var published = isPublished(childPath, publishedChildren);
        var writable = isWritable(childPath, publishedChildren);

        // Build indicators
        var indicators = '';
        if (published) {
            indicators += '<span class="indicator indicator-publish" title="Published">P</span>';
        }
        if (writable) {
            indicators += '<span class="indicator indicator-write" title="Writable">W</span>';
        }
        if (ignored) {
            indicators += '<span class="indicator indicator-ignore" title="Ignored">I</span>';
        }

        if (typeof value === 'object' && value !== null) {
            var childIsArray = Array.isArray(value);
            var count = childIsArray ? value.length : Object.keys(value).length;
            var summary = childIsArray ? '[' + count + ' items]' : '[' + count + ' fields]';

            html += '<div class="tag-child-row expandable collapsed' + (ignored ? ' ignored' : '') + (published ? ' published' : '') + '" ' +
                'onclick="handleChildClick(event, this)" ' +
                'data-key="' + escapeAttr(String(key)) + '" ' +
                'data-path="' + escapeAttr(childPath) + '" ' +
                'data-type="' + escapeAttr(valueType) + '" ' +
                'data-json="' + escapeAttr(JSON.stringify(value)) + '" ' +
                'data-ignore-list="' + escapeAttr(JSON.stringify(ignoreList)) + '" ' +
                'data-published-children="' + escapeAttr(JSON.stringify(publishedChildren)) + '">' +
                '<span class="child-expand" onclick="toggleChildExpand(event, this)">&#9660;</span>' +
                indicators +
                '<span class="child-key">' + escapeHtml(displayKey) + '</span>' +
                '<span class="child-type">(' + valueType + ')</span>' +
                '<span class="child-value">' + summary + '</span>' +
                '</div>' +
                '<div class="child-children" style="display:none"></div>';
        } else {
            html += '<div class="tag-child-row' + (ignored ? ' ignored' : '') + (published ? ' published' : '') + '" ' +
                'onclick="handleChildClick(event, this)" ' +
                'data-key="' + escapeAttr(String(key)) + '" ' +
                'data-path="' + escapeAttr(childPath) + '" ' +
                'data-type="' + escapeAttr(valueType) + '" ' +
                'data-json="' + escapeAttr(JSON.stringify(value)) + '">' +
                indicators +
                '<span class="child-key">' + escapeHtml(displayKey) + '</span>' +
                '<span class="child-type">(' + valueType + ')</span>' +
                '<span class="child-value">' + formatChildValue(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function toggleChildExpand(event, expandEl) {
    event.stopPropagation();
    var row = expandEl.closest('.tag-child-row');
    if (!row) return;

    var tagItem = row.closest('.tag-item');
    var plcGroup = row.closest('.plc-group');
    var plc = plcGroup ? plcGroup.dataset.plc : '';
    var tagName = tagItem ? tagItem.dataset.name : '';
    var tagKey = plc + '::' + tagName;
    var path = row.dataset.path;

    var wasCollapsed = row.classList.contains('collapsed');
    row.classList.toggle('collapsed');

    var childrenContainer = row.nextElementSibling;
    if (childrenContainer && childrenContainer.classList.contains('child-children')) {
        childrenContainer.style.display = wasCollapsed ? 'block' : 'none';

        // Build children on first expand
        if (wasCollapsed && childrenContainer.innerHTML === '') {
            var json = row.dataset.json;
            var ignoreList = [];
            var publishedChildren = {};
            try {
                var parsedIgnore = JSON.parse(row.dataset.ignoreList || '[]');
                ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
            } catch (e) {}
            try {
                // Get published children from parent row or tag item
                publishedChildren = JSON.parse(row.dataset.publishedChildren || tagItem.dataset.publishedChildren || '{}');
            } catch (e) {}
            try {
                var parsed = JSON.parse(json);
                if (typeof parsed === 'object' && parsed !== null) {
                    childrenContainer.innerHTML = buildTagChildren(parsed, path, ignoreList, publishedChildren);
                }
            } catch (e) {}
        }
    }

    // Update expanded state directly
    var fullKey = tagKey + '::' + path;
    if (wasCollapsed) {
        // Expanding - add to state
        expandedChildren[fullKey] = true;
    } else {
        // Collapsing - remove this path AND all descendants from state
        delete expandedChildren[fullKey];
        var prefix = fullKey + '.';
        for (var key in expandedChildren) {
            if (key.indexOf(prefix) === 0) {
                delete expandedChildren[key];
            }
        }
    }
    localStorage.setItem('republisher-children-expanded', JSON.stringify(expandedChildren));
}

function saveChildExpandState() {
    // This function rebuilds the entire expanded state from the DOM
    // Only called when we need a full refresh of state
    var expanded = {};
    document.querySelectorAll('.tag-item').forEach(function(tagItem) {
        var plcGroup = tagItem.closest('.plc-group');
        if (!plcGroup) return;
        var plc = plcGroup.dataset.plc;
        var tagName = tagItem.dataset.name;
        var tagKey = plc + '::' + tagName;

        // Only save children that are visible (all ancestors are expanded)
        tagItem.querySelectorAll('.tag-child-row.expandable:not(.collapsed)').forEach(function(row) {
            var path = row.dataset.path;
            if (path && isChildVisible(row)) {
                var fullKey = tagKey + '::' + path;
                expanded[fullKey] = true;
            }
        });
    });
    localStorage.setItem('republisher-children-expanded', JSON.stringify(expanded));
    expandedChildren = expanded;
}

function isChildVisible(row) {
    // Check if all ancestor containers are visible (not inside a collapsed parent)
    var current = row.parentElement;
    while (current) {
        if (current.classList.contains('tag-item')) {
            return true; // Reached the tag item, all ancestors are visible
        }
        if (current.classList.contains('child-children')) {
            // Check if this container is hidden
            if (current.style.display === 'none') {
                return false;
            }
            // Check if the parent row is collapsed
            var parentRow = current.previousElementSibling;
            if (parentRow && parentRow.classList.contains('collapsed')) {
                return false;
            }
        }
        current = current.parentElement;
    }
    return true;
}

function formatChildValue(value) {
    if (value === null) return '<span class="text-muted">null</span>';
    if (typeof value === 'boolean') {
        return value ? '<span class="text-success">true</span>' : '<span class="text-muted">false</span>';
    }
    if (typeof value === 'string') {
        var display = value.length > 20 ? value.substring(0, 20) + '...' : value;
        return '"' + escapeHtml(display) + '"';
    }
    return String(value);
}

function saveExpandState() {
    var expanded = {};
    document.querySelectorAll('.tag-item.has-children:not(.collapsed)').forEach(function(item) {
        var plc = item.closest('.plc-group').dataset.plc;
        var name = item.dataset.name;
        expanded[plc + '::' + name] = true;
    });
    localStorage.setItem('republisher-expanded', JSON.stringify(expanded));
    expandedTags = expanded;
}

function restoreChildExpandState() {
    // Iterate through all expanded tag items and restore their child states
    document.querySelectorAll('.tag-item.has-children:not(.collapsed)').forEach(function(tagItem) {
        var plcGroup = tagItem.closest('.plc-group');
        if (!plcGroup) return;
        var plc = plcGroup.dataset.plc;
        var tagName = tagItem.dataset.name;
        var tagKey = plc + '::' + tagName;

        // Get ignore list and published children for building children
        var ignoreList = [];
        var publishedChildren = {};
        try {
            var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
        } catch (e) {}
        try {
            publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
        } catch (e) {}

        // Collect all paths for this tag that should be expanded, sorted by depth
        var pathsToExpand = [];
        for (var key in expandedChildren) {
            if (key.indexOf(tagKey + '::') === 0) {
                pathsToExpand.push(key.substring(tagKey.length + 2));
            }
        }
        pathsToExpand.sort(function(a, b) {
            return a.split('.').length - b.split('.').length;
        });

        // Expand each path in order (parents first due to sorting)
        pathsToExpand.forEach(function(pathToExpand) {
            expandChildPath(tagItem, pathToExpand, ignoreList, publishedChildren);
        });
    });
}

function expandChildPath(tagItem, targetPath, ignoreList, publishedChildren) {
    // Walk through the path and ensure each level is built and expanded
    var parts = targetPath.split('.');
    var currentPath = '';

    for (var i = 0; i < parts.length; i++) {
        currentPath = currentPath ? currentPath + '.' + parts[i] : parts[i];

        var row = tagItem.querySelector('.tag-child-row[data-path="' + CSS.escape(currentPath) + '"]');
        if (!row || !row.classList.contains('expandable')) {
            return; // Can't find this level, stop
        }

        var childContainer = row.nextElementSibling;
        if (!childContainer || !childContainer.classList.contains('child-children')) {
            return; // No container, stop
        }

        // Build children if not yet built
        if (childContainer.innerHTML === '') {
            var json = row.dataset.json;
            try {
                var parsed = JSON.parse(json);
                if (typeof parsed === 'object' && parsed !== null) {
                    childContainer.innerHTML = buildTagChildren(parsed, currentPath, ignoreList, publishedChildren);
                }
            } catch (e) {
                return; // Failed to build, stop
            }
        }

        // Expand this level (needed to reach deeper levels or if this is the target)
        row.classList.remove('collapsed');
        childContainer.style.display = 'block';
    }
}

function updateDetailsPanel(info) {
    var details = document.getElementById('republisher-details');

    // Save scroll position before updating
    var scrollTop = details ? details.scrollTop : 0;

    if (!info) {
        details.innerHTML = '<div class="details-placeholder">Select a tag to view details</div>';
        return;
    }

    var valueHtml = '';
    try {
        var parsed = JSON.parse(info.json);
        if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
            valueHtml = '<div class="value-tree">' + buildValueTree(parsed, '') + '</div>';
        } else if (Array.isArray(parsed)) {
            valueHtml = '<div class="value-tree">' + buildArrayTree(parsed, '') + '</div>';
        } else {
            valueHtml = '<div class="value-simple mono">' + escapeHtml(String(parsed)) + '</div>';
        }
    } catch (e) {
        valueHtml = '<div class="value-simple mono">' + escapeHtml(info.json || '-') + '</div>';
    }

    // Check if this member is ignored
    var memberIgnored = info.path && info.ignoreList && info.ignoreList.indexOf(info.path) >= 0;

    // Build action bar with all three options
    var actionBar = '<div class="details-actions">';

    if (!info.path) {
        // Root tag controls (no Ignore Changes - that's only for child members)
        actionBar += '<label class="toggle-label">' +
            '<input type="checkbox" ' + (info.enabled ? 'checked' : '') +
            ' onchange="toggleTagEnabled(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', this.checked)">' +
            '<span>Published</span>' +
            '</label>' +
            '<label class="toggle-label">' +
            '<input type="checkbox" ' + (info.writable ? 'checked' : '') +
            ' onchange="toggleTagWritable(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', this.checked)">' +
            '<span>Writable</span>' +
            '</label>';
    } else {
        // Member controls
        // Published = adds member as a separate published tag
        // Ignored = in parent's ignore list (changes don't trigger republish, but value is still included)
        // Writable = makes the member writable
        var memberPublished = info.memberPublished || false;
        var memberWritable = info.memberWritable || false;
        actionBar += '<label class="toggle-label">' +
            '<input type="checkbox" ' + (memberPublished ? 'checked' : '') +
            ' onchange="toggleMemberEnabled(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)" ' +
            'title="Publish this member as a separate tag (independent of parent)">' +
            '<span>Published</span>' +
            '</label>' +
            '<label class="toggle-label">' +
            '<input type="checkbox" ' + (memberIgnored ? 'checked' : '') +
            ' onchange="toggleMemberIgnored(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)" ' +
            'title="When checked, changes to this member will not trigger a republish of the parent tag (value is still included in published data)">' +
            '<span>Ignore Changes</span>' +
            '</label>' +
            '<label class="toggle-label">' +
            '<input type="checkbox" ' + (memberWritable ? 'checked' : '') +
            ' onchange="toggleMemberWritable(\'' + escapeAttr(info.plc) + '\', \'' + escapeAttr(info.tagName) + '\', \'' + escapeAttr(info.path) + '\', this.checked)" ' +
            'title="Make this member writable">' +
            '<span>Writable</span>' +
            '</label>';
    }
    actionBar += '</div>';

    // Build display name
    var displayName = info.path ? info.tagName + '.' + info.path : info.name;

    // Build write section if tag is writable
    var canWrite = (!info.path && info.writable) || (info.path && info.memberWritable);
    var writeHtml = '';
    if (canWrite) {
        var currentValue = '';
        try {
            var parsed = JSON.parse(info.json);
            if (typeof parsed !== 'object' || parsed === null) {
                currentValue = String(parsed);
            }
        } catch (e) {
            currentValue = info.json || '';
        }
        var writePath = info.path ? info.tagName + '.' + info.path : info.tagName;
        writeHtml = '<div class="write-section" style="margin-top:1rem">' +
            '<h4>Write Value</h4>' +
            '<div style="display:flex;gap:0.5rem;align-items:flex-start">' +
            '<input type="text" id="write-value-input" class="form-control" placeholder="Enter value" value="' + escapeAttr(currentValue) + '" style="flex:1" ' +
            'onkeydown="if(event.key===\'Enter\')writeTagValue(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(writePath) + '\')">' +
            '<button class="btn btn-sm" onclick="writeTagValue(\'' + escapeAttr(info.plc) + '\',\'' + escapeAttr(writePath) + '\')" ' +
            'style="white-space:nowrap">Write</button>' +
            '</div>' +
            '<div id="write-result" style="margin-top:0.25rem;font-size:0.85em"></div>' +
            '</div>';
    }

    details.innerHTML =
        '<div class="details-content">' +
        '<h3>' + (info.path ? 'Member Details' : 'Tag Details') + '</h3>' +
        actionBar +
        '<table class="details-table">' +
        '<tr><th>PLC</th><td>' + escapeHtml(info.plc) + '</td></tr>' +
        '<tr><th>Name</th><td class="mono">' + escapeHtml(displayName) + '</td></tr>' +
        (info.alias ? '<tr><th>Alias</th><td>' + escapeHtml(info.alias) + '</td></tr>' : '') +
        '<tr><th>Type</th><td class="mono">' + escapeHtml(info.type || '-') + '</td></tr>' +
        (info.lastPoll ? '<tr><th>Last Read</th><td>' + escapeHtml(info.lastPoll) + '</td></tr>' : '') +
        (info.lastChanged ? '<tr><th>Last Changed</th><td>' + escapeHtml(info.lastChanged) + '</td></tr>' : '') +
        (info.hasIgnores && !info.path ? '<tr><th>Ignores</th><td>' + info.ignoreCount + ' members</td></tr>' : '') +
        '</table>' +
        '<h4 style="margin-top:1rem">Value</h4>' +
        valueHtml +
        writeHtml +
        '</div>';

    // Restore expanded state for value tree nodes
    restoreValueTreeState();

    // Restore scroll position after browser renders
    requestAnimationFrame(function() {
        details.scrollTop = scrollTop;
    });
}

function restoreValueTreeState() {
    var details = document.getElementById('republisher-details');
    if (!details || !selectedInfo) return;

    var selectionKey = getSelectionKey();
    var expandedPaths = expandedValueNodes[selectionKey] || {};

    details.querySelectorAll('.tree-node.expandable[data-node-path]').forEach(function(node) {
        var nodePath = node.dataset.nodePath;
        if (expandedPaths[nodePath]) {
            node.classList.remove('collapsed');
            var children = node.nextElementSibling;
            if (children && children.classList.contains('tree-children')) {
                children.style.display = 'block';
            }
        }
    });
}

function escapeAttr(text) {
    if (text === null || text === undefined) return '';
    return text.replace(/&/g, '&amp;').replace(/'/g, '&#39;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function toggleTagEnabled(plc, tagName, enabled) {
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({enabled: enabled})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and DOM immediately for responsive feedback
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc && !selectedInfo.path) {
            selectedInfo.enabled = enabled;
            updateDetailsPanel(selectedInfo);
        }
        // Update the tag row's visual state
        var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
        if (plcGroup) {
            var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
            if (tagItem) {
                tagItem.dataset.enabled = enabled;
                var tagRow = tagItem.querySelector('.tag-row');
                if (tagRow) {
                    if (enabled) {
                        tagRow.classList.add('monitored');
                    } else {
                        tagRow.classList.remove('monitored');
                    }
                }
                // Update indicators to show/hide P indicator
                updateTagIndicators(tagItem, tagItem.dataset.hasIgnores === 'true', tagItem.dataset.writable === 'true', enabled);
            }
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleTagWritable(plc, tagName, writable) {
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({writable: writable})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and DOM immediately
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc && !selectedInfo.path) {
            selectedInfo.writable = writable;
            updateDetailsPanel(selectedInfo);
        }
        // Update the tag item's data and indicators
        var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
        if (plcGroup) {
            var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
            if (tagItem) {
                tagItem.dataset.writable = writable;
                updateTagIndicators(tagItem, tagItem.dataset.hasIgnores === 'true', writable);
            }
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function updateTagIndicators(tagItem, hasIgnores, writable, enabled) {
    var indicators = tagItem.querySelector('.tag-indicators');
    if (indicators) {
        // Use enabled from parameter if provided, otherwise from data attribute
        var isEnabled = enabled !== undefined ? enabled : tagItem.dataset.enabled === 'true';
        var html = '';
        if (isEnabled) {
            html += '<span class="indicator indicator-publish" title="Published">P</span>';
        }
        if (hasIgnores) {
            var ignoreCount = parseInt(tagItem.dataset.ignoreCount) || 0;
            html += '<span class="indicator indicator-ignore" title="Has ' + ignoreCount + ' ignored members">I</span>';
        }
        if (writable) {
            html += '<span class="indicator indicator-write" title="Writable">W</span>';
        }
        indicators.innerHTML = html;
    }
}

function toggleTagIgnored(plc, tagName, ignored) {
    // Use "*" to indicate the entire tag is ignored
    var body = ignored ? {add_ignore: ['*']} : {remove_ignore: ['*']};
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagName), {
        method: 'PATCH',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // SSE will push the update - just update local state for immediate feedback
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.plc === plc) {
            selectedInfo.hasIgnores = ignored;
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleMemberIgnored(plc, tagName, path, ignored) {
    // Build list of all published parents that need their ignore lists updated
    // For example, if path is "Position.Counter" and both "Robot1" and "Robot1.Position" are published,
    // we need to add "Position.Counter" to Robot1's ignore list and "Counter" to Robot1.Position's ignore list

    var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
    if (!plcGroup) return;
    var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
    if (!tagItem) return;

    // Get published children to find intermediate published parents
    var publishedChildren = {};
    try {
        var parsed = JSON.parse(tagItem.dataset.publishedChildren || '{}');
        publishedChildren = (typeof parsed === 'object' && parsed !== null) ? parsed : {};
    } catch (e) {}

    // Build list of API calls needed: root tag + any intermediate published parents
    var apiCalls = [];

    // 1. Always update the root tag with the full path
    apiCalls.push({
        fullTagName: tagName,
        ignorePath: path
    });

    // 2. Find any intermediate published parents and add relative paths
    var pathParts = path.split('.');
    var currentPath = '';
    for (var i = 0; i < pathParts.length - 1; i++) {
        currentPath = currentPath ? currentPath + '.' + pathParts[i] : pathParts[i];
        // Check if this intermediate path is published
        if (publishedChildren[currentPath] && publishedChildren[currentPath].enabled !== false) {
            // This intermediate path is published, add the relative path from here
            var relativePath = pathParts.slice(i + 1).join('.');
            apiCalls.push({
                fullTagName: tagName + '.' + currentPath,
                ignorePath: relativePath
            });
        }
    }

    // Execute all API calls
    var promises = apiCalls.map(function(call) {
        var body = ignored ? {add_ignore: [call.ignorePath]} : {remove_ignore: [call.ignorePath]};
        return fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(call.fullTagName), {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
        });
    });

    Promise.all(promises)
    .then(function(responses) {
        // Check if any failed
        for (var i = 0; i < responses.length; i++) {
            if (!responses[i].ok) {
                throw new Error('Failed to update ignore list');
            }
        }

        // Update local state and DOM immediately
        // Update ignore list in root tag's data attribute
        var ignoreList = [];
        try {
            var parsed = JSON.parse(tagItem.dataset.ignoreList || '[]');
            ignoreList = Array.isArray(parsed) ? parsed : [];
        } catch (e) {}

        if (ignored) {
            if (ignoreList.indexOf(path) < 0) {
                ignoreList.push(path);
            }
        } else {
            ignoreList = ignoreList.filter(function(p) { return p !== path; });
        }
        tagItem.dataset.ignoreList = JSON.stringify(ignoreList);
        tagItem.dataset.hasIgnores = ignoreList.length > 0;
        tagItem.dataset.ignoreCount = ignoreList.length;

        // Update the child row's visual state
        var childRow = tagItem.querySelector('.tag-child-row[data-path="' + path + '"]');
        if (childRow) {
            if (ignored) {
                childRow.classList.add('ignored');
            } else {
                childRow.classList.remove('ignored');
            }
            // Update ignore indicator
            var existingIndicator = childRow.querySelector('.indicator-ignore');
            if (ignored && !existingIndicator) {
                var span = document.createElement('span');
                span.className = 'indicator indicator-ignore';
                span.title = 'Ignored';
                span.textContent = 'I';
                var insertAfter = childRow.querySelector('.indicator-write') || childRow.querySelector('.indicator-publish') || childRow.querySelector('.child-expand');
                if (insertAfter) {
                    insertAfter.after(span);
                } else {
                    childRow.insertBefore(span, childRow.firstChild);
                }
            } else if (!ignored && existingIndicator) {
                existingIndicator.remove();
            }
        }

        // Update tag indicators (to show/hide the parent's I indicator)
        updateTagIndicators(tagItem, ignoreList.length > 0, tagItem.dataset.writable === 'true');

        // Update details panel if this member is selected
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
            // Update ignoreList in selectedInfo (ensure it's an array)
            if (!Array.isArray(selectedInfo.ignoreList)) {
                selectedInfo.ignoreList = [];
            }
            if (ignored) {
                if (selectedInfo.ignoreList.indexOf(path) < 0) {
                    selectedInfo.ignoreList.push(path);
                }
            } else {
                selectedInfo.ignoreList = selectedInfo.ignoreList.filter(function(p) { return p !== path; });
            }
            updateDetailsPanel(selectedInfo);
        }
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function toggleMemberEnabled(plc, tagName, path, enabled) {
    // Add/update member as a separate published tag
    var fullPath = tagName + '.' + path;
    if (enabled) {
        // Create/enable the member tag
        fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({enabled: true, writable: false})
        })
        .then(function(response) {
            if (!response.ok) {
                return response.text().then(function(msg) { throw new Error(msg); });
            }
            // Update local state and details panel
            if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
                selectedInfo.memberPublished = true;
                updateDetailsPanel(selectedInfo);
            }
            // Update published children tracking and visual state
            updatePublishedChildren(plc, tagName, path, true, false);
        })
        .catch(function(err) {
            alert('Error: ' + err.message);
        });
    } else {
        // Disable the member tag
        fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
            method: 'PATCH',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({enabled: false})
        })
        .then(function(response) {
            if (!response.ok) {
                return response.text().then(function(msg) { throw new Error(msg); });
            }
            // Update local state and details panel
            if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
                selectedInfo.memberPublished = false;
                updateDetailsPanel(selectedInfo);
            }
            // Update published children tracking and visual state
            updatePublishedChildren(plc, tagName, path, false, false);
        })
        .catch(function(err) {
            alert('Error: ' + err.message);
        });
    }
}

function toggleMemberWritable(plc, tagName, path, writable) {
    // Set writable on the member path (adds as separate tag if needed, or updates existing)
    var fullPath = tagName + '.' + path;
    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(fullPath), {
        method: 'PUT',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({writable: writable, enabled: true})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        // Update local state and details panel
        if (selectedInfo && selectedInfo.tagName === tagName && selectedInfo.path === path && selectedInfo.plc === plc) {
            selectedInfo.memberWritable = writable;
            selectedInfo.memberPublished = true;
            updateDetailsPanel(selectedInfo);
        }
        // Update published children tracking and visual state
        updatePublishedChildren(plc, tagName, path, true, writable);
    })
    .catch(function(err) {
        alert('Error: ' + err.message);
    });
}

function writeTagValue(plc, tagPath) {
    var input = document.getElementById('write-value-input');
    var resultDiv = document.getElementById('write-result');
    if (!input) return;

    var rawValue = input.value;
    // Parse the value: booleans, numbers, or string
    var value;
    if (rawValue === 'true') value = true;
    else if (rawValue === 'false') value = false;
    else if (rawValue !== '' && !isNaN(Number(rawValue))) value = Number(rawValue);
    else value = rawValue;

    resultDiv.innerHTML = '<span class="text-muted">Writing...</span>';

    fetch('/htmx/tags/' + encodeURIComponent(plc) + '/' + encodeURIComponent(tagPath) + '/write', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({value: value})
    })
    .then(function(response) {
        if (!response.ok) {
            return response.text().then(function(msg) { throw new Error(msg); });
        }
        resultDiv.innerHTML = '<span class="text-success">Value written successfully</span>';
        setTimeout(function() { resultDiv.innerHTML = ''; }, 3000);
    })
    .catch(function(err) {
        resultDiv.innerHTML = '<span class="text-danger">Error: ' + escapeHtml(err.message) + '</span>';
    });
}

function updatePublishedChildren(plc, tagName, path, published, writable) {
    var plcGroup = document.querySelector('.plc-group[data-plc="' + plc + '"]');
    if (!plcGroup) return;
    var tagItem = plcGroup.querySelector('.tag-item[data-name="' + tagName + '"]');
    if (!tagItem) return;

    // Update the published-children data attribute
    var publishedChildren = {};
    try {
        publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
    } catch (e) {}

    if (published) {
        publishedChildren[path] = {enabled: true, writable: writable || false};
    } else {
        delete publishedChildren[path];
    }
    tagItem.dataset.publishedChildren = JSON.stringify(publishedChildren);

    // Update the child row visual state
    var childRow = tagItem.querySelector('.tag-child-row[data-path="' + path + '"]');
    if (childRow) {
        // Add/remove .published class for bold green styling
        if (published) {
            childRow.classList.add('published');
        } else {
            childRow.classList.remove('published');
        }

        // Update the published indicator
        var existingPublishIndicator = childRow.querySelector('.indicator-publish');
        if (published && !existingPublishIndicator) {
            var span = document.createElement('span');
            span.className = 'indicator indicator-publish';
            span.title = 'Published';
            span.textContent = 'P';
            // Insert after expand button if present
            var expandBtn = childRow.querySelector('.child-expand');
            if (expandBtn) {
                expandBtn.after(span);
            } else {
                childRow.insertBefore(span, childRow.firstChild);
            }
        } else if (!published && existingPublishIndicator) {
            existingPublishIndicator.remove();
        }

        // Update the writable indicator
        var existingWriteIndicator = childRow.querySelector('.indicator-write');
        if (writable && !existingWriteIndicator) {
            var wspan = document.createElement('span');
            wspan.className = 'indicator indicator-write';
            wspan.title = 'Writable';
            wspan.textContent = 'W';
            // Insert after publish indicator or expand button
            var insertAfter = childRow.querySelector('.indicator-publish') || childRow.querySelector('.child-expand');
            if (insertAfter) {
                insertAfter.after(wspan);
            } else {
                childRow.insertBefore(wspan, childRow.firstChild);
            }
        } else if (!writable && existingWriteIndicator) {
            existingWriteIndicator.remove();
        }
    }
}

function buildValueTree(obj, parentPath) {
    var html = '';
    var keys = Object.keys(obj).sort();

    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = obj[key];
        var valueType = getValueType(value);
        var nodePath = parentPath ? parentPath + '.' + key : key;

        if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                // Array
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                    '<span class="tree-type">(' + valueType + ')</span>' +
                    '<span class="tree-summary">[' + value.length + ' items]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildArrayTree(value, nodePath) + '</div>';
            } else {
                // Nested object
                var fieldCount = Object.keys(value).length;
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                    '<span class="tree-type">(' + valueType + ')</span>' +
                    '<span class="tree-summary">[' + fieldCount + ' fields]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildValueTree(value, nodePath) + '</div>';
            }
        } else {
            // Primitive value
            html += '<div class="tree-node">' +
                '<span class="tree-key">' + escapeHtml(key) + '</span>' +
                '<span class="tree-type">(' + valueType + ')</span>' +
                '<span class="tree-value">' + formatPrimitive(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function buildArrayTree(arr, parentPath) {
    var html = '';
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        var valueType = getValueType(value);
        var nodePath = parentPath ? parentPath + '[' + i + ']' : '[' + i + ']';

        if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">[' + i + ']</span>' +
                    '<span class="tree-type">(Array)</span>' +
                    '<span class="tree-summary">[' + value.length + ' items]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildArrayTree(value, nodePath) + '</div>';
            } else {
                var fieldCount = Object.keys(value).length;
                html += '<div class="tree-node expandable collapsed" data-node-path="' + escapeAttr(nodePath) + '" onclick="toggleTreeNode(event, this)">' +
                    '<span class="tree-expand">&#9660;</span>' +
                    '<span class="tree-key">[' + i + ']</span>' +
                    '<span class="tree-type">(' + valueType + ')</span>' +
                    '<span class="tree-summary">[' + fieldCount + ' fields]</span>' +
                    '</div>' +
                    '<div class="tree-children" style="display:none">' + buildValueTree(value, nodePath) + '</div>';
            }
        } else {
            html += '<div class="tree-node">' +
                '<span class="tree-key">[' + i + ']</span>' +
                '<span class="tree-type">(' + valueType + ')</span>' +
                '<span class="tree-value">' + formatPrimitive(value) + '</span>' +
                '</div>';
        }
    }
    return html;
}

function getValueType(value) {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'Array';
    if (typeof value === 'object') return 'Object';
    if (typeof value === 'boolean') return 'BOOL';
    if (typeof value === 'number') {
        return Number.isInteger(value) ? 'INT' : 'REAL';
    }
    if (typeof value === 'string') return 'STRING';
    return typeof value;
}

function formatPrimitive(value) {
    if (value === null) return '<span class="text-muted">null</span>';
    if (typeof value === 'boolean') {
        return '<span class="text-' + (value ? 'success' : 'muted') + '">' + value + '</span>';
    }
    if (typeof value === 'number') {
        return '<span class="text-primary">' + value + '</span>';
    }
    if (typeof value === 'string') {
        return '<span class="text-string">"' + escapeHtml(value) + '"</span>';
    }
    return escapeHtml(String(value));
}

function toggleTreeNode(event, el) {
    event.stopPropagation();
    var children = el.nextElementSibling;
    if (children && children.classList.contains('tree-children')) {
        var isCollapsed = el.classList.contains('collapsed');
        el.classList.toggle('collapsed');
        children.style.display = isCollapsed ? 'block' : 'none';

        // Save expanded state scoped to current selection
        var nodePath = el.dataset.nodePath;
        if (nodePath && selectedInfo) {
            var selectionKey = getSelectionKey();
            if (!expandedValueNodes[selectionKey]) {
                expandedValueNodes[selectionKey] = {};
            }
            if (isCollapsed) {
                expandedValueNodes[selectionKey][nodePath] = true;
            } else {
                delete expandedValueNodes[selectionKey][nodePath];
            }
            localStorage.setItem('republisher-value-expanded', JSON.stringify(expandedValueNodes));
        }
    }
}

function getSelectionKey() {
    if (!selectedInfo) return '';
    return selectedInfo.plc + '::' + selectedInfo.tagName + (selectedInfo.path ? '::' + selectedInfo.path : '');
}


function togglePLC(el) {
    var plcGroup = el.closest('.plc-group');
    var plcName = plcGroup.dataset.plc;
    plcGroup.classList.toggle('collapsed');

    // Save collapsed state
    if (plcGroup.classList.contains('collapsed')) {
        collapsedPLCs[plcName] = true;
    } else {
        delete collapsedPLCs[plcName];
    }
    localStorage.setItem('republisher-collapsed', JSON.stringify(collapsedPLCs));
}

function toggleSection(el) {
    var sectionGroup = el.closest('.section-group');
    var plcGroup = el.closest('.plc-group');
    var plcName = plcGroup ? plcGroup.dataset.plc : '';
    var sectionName = sectionGroup.dataset.section;
    var key = plcName + '::' + sectionName;

    sectionGroup.classList.toggle('collapsed');

    // Save collapsed state
    if (sectionGroup.classList.contains('collapsed')) {
        collapsedSections[key] = true;
    } else {
        delete collapsedSections[key];
    }
    localStorage.setItem('republisher-sections-collapsed', JSON.stringify(collapsedSections));
}

function restoreState() {
    // Restore PLC collapsed state
    document.querySelectorAll('.plc-group').forEach(function(group) {
        var plcName = group.dataset.plc;
        if (collapsedPLCs[plcName]) {
            group.classList.add('collapsed');
        }
    });

    // Restore section collapsed state
    document.querySelectorAll('.section-group').forEach(function(section) {
        var plcGroup = section.closest('.plc-group');
        var plcName = plcGroup ? plcGroup.dataset.plc : '';
        var sectionName = section.dataset.section;
        var key = plcName + '::' + sectionName;
        if (collapsedSections[key]) {
            section.classList.add('collapsed');
        }
    });

    // Restore tag expanded state and build children
    document.querySelectorAll('.tag-item.has-children').forEach(function(item) {
        var plc = item.closest('.plc-group').dataset.plc;
        var name = item.dataset.name;
        var key = plc + '::' + name;
        if (expandedTags[key]) {
            item.classList.remove('collapsed');
            buildTagChildrenIfNeeded(item);
        }
    });

    // Restore child expanded state
    restoreChildExpandState();

    // Restore selection
    if (selectedInfo && selectedInfo.plc && selectedInfo.tagName) {
        var tagItem = document.querySelector(
            '.plc-group[data-plc="' + selectedInfo.plc + '"] .tag-item[data-name="' + selectedInfo.tagName + '"]'
        );

        if (tagItem) {
            // Update the stored data from current DOM
            selectedInfo.json = tagItem.dataset.json;
            selectedInfo.type = tagItem.dataset.type;
            selectedInfo.enabled = tagItem.dataset.enabled === 'true';
            selectedInfo.writable = tagItem.dataset.writable === 'true';
            selectedInfo.hasIgnores = tagItem.dataset.hasIgnores === 'true';
            selectedInfo.ignoreCount = parseInt(tagItem.dataset.ignoreCount) || 0;
            selectedInfo.lastPoll = tagItem.dataset.lastPoll || '';
            selectedInfo.lastChanged = tagItem.dataset.lastChanged || '';

            // Get ignore list and published children from tag item
            var ignoreList = [];
            var publishedChildren = {};
            try {
                var parsedIgnore = JSON.parse(tagItem.dataset.ignoreList || '[]');
        ignoreList = Array.isArray(parsedIgnore) ? parsedIgnore : [];
            } catch (e) {}
            try {
                publishedChildren = JSON.parse(tagItem.dataset.publishedChildren || '{}');
            } catch (e) {}
            selectedInfo.ignoreList = ignoreList;

            if (selectedInfo.path) {
                // Child was selected - need to expand parent and find child
                tagItem.classList.remove('collapsed');
                buildTagChildrenIfNeeded(tagItem);

                // Expand all intermediate nodes in the path
                var pathParts = selectedInfo.path.split('.');
                var currentPath = '';
                for (var i = 0; i < pathParts.length - 1; i++) {
                    currentPath = currentPath ? currentPath + '.' + pathParts[i] : pathParts[i];
                    var parentRow = tagItem.querySelector('.tag-child-row[data-path="' + currentPath + '"]');
                    if (parentRow && parentRow.classList.contains('expandable')) {
                        parentRow.classList.remove('collapsed');
                        var childContainer = parentRow.nextElementSibling;
                        if (childContainer && childContainer.classList.contains('child-children')) {
                            childContainer.style.display = 'block';
                            if (childContainer.innerHTML === '') {
                                var json = parentRow.dataset.json;
                                try {
                                    var parsed = JSON.parse(json);
                                    if (typeof parsed === 'object' && parsed !== null) {
                                        childContainer.innerHTML = buildTagChildren(parsed, currentPath, ignoreList, publishedChildren);
                                    }
                                } catch (e) {}
                            }
                        }
                    }
                }

                // Update the JSON value for selected child
                try {
                    var parsed = JSON.parse(tagItem.dataset.json);
                    for (var i = 0; i < pathParts.length; i++) {
                        if (parsed && typeof parsed === 'object') {
                            parsed = parsed[pathParts[i]];
                        }
                    }
                    if (parsed !== undefined) {
                        selectedInfo.json = JSON.stringify(parsed);
                        selectedInfo.type = getValueType(parsed);
                    }
                } catch (e) {}

                // Update published/writable state for the selected child
                var childInfo = publishedChildren[selectedInfo.path] || {};
                selectedInfo.memberPublished = childInfo.enabled !== undefined ? childInfo.enabled : (childInfo === true);
                selectedInfo.memberWritable = childInfo.writable === true;

                // Find and select the child row
                var childRow = tagItem.querySelector('.tag-child-row[data-path="' + selectedInfo.path + '"]');
                if (childRow) {
                    childRow.classList.add('selected');
                }
            } else {
                // Root tag was selected
                var tagRow = tagItem.querySelector('.tag-row');
                if (tagRow) {
                    tagRow.classList.add('selected');
                }
            }

            // Update details - scroll is preserved inside updateDetailsPanel
            updateDetailsPanel(selectedInfo);
        }
    }
}

function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Restore state on initial load
document.addEventListener('DOMContentLoaded', restoreState);
</script>
<script src="/static/js/sse-events.js"></script>

{{template "footer" .}}
